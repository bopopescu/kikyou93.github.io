{"meta":{"title":"kikfan","subtitle":"lack is rich, self-discipline to produce joy!","description":"偏安一隅","author":"Gustave","url":"https://www.kikfan.com"},"pages":[{"title":"","date":"2020-07-16T17:22:23.747Z","updated":"2020-07-16T17:22:23.747Z","comments":true,"path":"baidu_verify_XA3AkgWFsu.html","permalink":"https://www.kikfan.com/baidu_verify_XA3AkgWFsu.html","excerpt":"","text":"XA3AkgWFsu"},{"title":"","date":"2020-07-16T17:22:23.747Z","updated":"2020-07-16T17:22:23.747Z","comments":true,"path":"googlec29f08c34e9b5960.html","permalink":"https://www.kikfan.com/googlec29f08c34e9b5960.html","excerpt":"","text":"google-site-verification: googlec29f08c34e9b5960.html"},{"title":"categories","date":"2018-01-04T03:45:41.000Z","updated":"2020-07-16T17:22:23.747Z","comments":false,"path":"categories/index.html","permalink":"https://www.kikfan.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-07-16T17:22:23.747Z","updated":"2020-07-16T17:22:23.747Z","comments":true,"path":"links/index.html","permalink":"https://www.kikfan.com/links/index.html","excerpt":"","text":"#"},{"title":"tags","date":"2018-01-04T03:45:41.000Z","updated":"2020-07-16T17:22:23.747Z","comments":false,"path":"tags/index.html","permalink":"https://www.kikfan.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"git","slug":"git","date":"2020-07-05T03:32:10.000Z","updated":"2020-07-05T03:32:10.000Z","comments":true,"path":"archives/43167.html","link":"","permalink":"https://www.kikfan.com/archives/43167.html","excerpt":"","text":"git reset –hard –soft –mixed区别使用方法git reset --mixed/--hard/--soft 41e1d58739a5ab280b5b2dbde107c14aeeb0b6d2 git –soft只是删除某次提交,再次提交直接commit即可 git –mixed-删除某次提交,并且回到add之前的状态,再次提交先add 在commit git –hard删除末次提交,并清空所有基于41e1d58739a5ab280b5b2dbde107c14aeeb0b6d2这次commit的修改.可能会造成数据丢失. git cherry-pick {commit_id} …合并一条或者多条的commit 记录 git rebase {branch}将当前分支基点置于另一分支的最后一个提交的位置，同样可以更新另一分支的内容，与merge的区别是1、rebase更加干净2、rebase 是线性的提交记录 git rebase -i {commit_id}交互模式，操作当前分支所在位置，通常用于插入commit，删除commit，合并commit等，功能较为强大 Commands: p, pick = use commit r, reword = use commit, but edit the commit message e, edit = use commit, but stop for amending s, squash = use commit, but meld into previous commit f, fixup = like “squash”, but discard this commit’s log message x, exec = run command (the rest of the line) using shell d, drop = remove commit merge 与 rebase的选择 不要在公共分支上使用rebase，因为rebase会修改提交记录，否则会造成回溯的困难","categories":[{"name":"实用工具","slug":"实用工具","permalink":"https://www.kikfan.com/categories/实用工具/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.kikfan.com/tags/git/"}]},{"title":"SearchQuickByShortcut","slug":"SearchQuickByShortcut","date":"2020-06-05T03:11:58.000Z","updated":"2020-06-05T03:11:58.000Z","comments":true,"path":"archives/137c7eea.html","link":"","permalink":"https://www.kikfan.com/archives/137c7eea.html","excerpt":"","text":"前言 作为码农，总免不了开心地撸着代码的时候需要查下谷歌、stackoverflow等，那就得切到浏览器-&gt;输入网址-&gt;搜索，那就很烦，这款插件应运而生 使用 IDEA marketplace 中搜索 SearchQuickByShortcut，安装 选中或不选中文字，按对应快捷键跳转进行搜索，当然你也可以在keymap中自定义 以下为对应网址的默认快捷键alt + Bgo baidu with text or notalt + Wgo stackoverflow with text or notalt + Ggo google with text or notalt + Ygo youdao with text or not","categories":[{"name":"好奇尚异","slug":"好奇尚异","permalink":"https://www.kikfan.com/categories/好奇尚异/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://www.kikfan.com/tags/IDEA/"},{"name":"Plugin","slug":"Plugin","permalink":"https://www.kikfan.com/tags/Plugin/"}]},{"title":"openvpn+frp实现内网穿透远程办公","slug":"openvpn-frp实现内网穿透远程办公","date":"2020-06-03T20:48:04.000Z","updated":"2020-06-03T20:48:04.000Z","comments":true,"path":"archives/87304ffa.html","link":"","permalink":"https://www.kikfan.com/archives/87304ffa.html","excerpt":"","text":"openvpn 使用Nyr大神的一键脚本即可（注：数据源上面吃了小亏，package 错误，不再犯）script1wget https://git.io/vpn -O openvpn-install.sh &amp;&amp; bash openvpn-install.sh frp- 站在巨人的肩膀上，同样简单操作，注意需要配置服务以防频繁掉（linux 配置系统服务）vi /lib/systemd/system/frpc.servicescript1234567891011121314151617[Unit] Description=frpc serviceAfter=network.target syslog.targetWants=network.target[Service]Type=simpleExecStart=/root/frp_0.33.0_linux_amd64/frpc -c /root/frp_0.33.0_linux_amd64/frpc.ini[Install]WantedBy=multi-user.target systemctl enable frpc systemctl start frpc 配置frp的过程中有个小坑，frpc的映射必须填所在网段的地址script12345[vpn]type = tcplocal_ip = 192.168.0.0local_port = remote_port =","categories":[{"name":"好奇尚异","slug":"好奇尚异","permalink":"https://www.kikfan.com/categories/好奇尚异/"}],"tags":[{"name":"frp","slug":"frp","permalink":"https://www.kikfan.com/tags/frp/"},{"name":"内网穿透","slug":"内网穿透","permalink":"https://www.kikfan.com/tags/内网穿透/"},{"name":"openvpn","slug":"openvpn","permalink":"https://www.kikfan.com/tags/openvpn/"}]},{"title":"阴阳师外挂","slug":"阴阳师外挂","date":"2020-05-09T16:02:10.000Z","updated":"2020-05-09T16:02:10.000Z","comments":true,"path":"archives/63a2eef1.html","link":"","permalink":"https://www.kikfan.com/archives/63a2eef1.html","excerpt":"咸鱼地有些时日没动博客，最近回坑了下阴阳师，旨在养肝，遂心血来潮写写自动脚本，封号即脱坑，终是闲云野鹤","text":"咸鱼地有些时日没动博客，最近回坑了下阴阳师，旨在养肝，遂心血来潮写写自动脚本，封号即脱坑，终是闲云野鹤 前言初步功能：自动魂土并点怪，自动结界，自动换结界卡 基石在相应的分辨率下截图，并存入内存中，后续进行比对123456File file = new File(absolutePath + \"/images/\" + fblpath);String[] fileList = file.list();for (String fileName : fileList) &#123; System.out.println(fileName.substring(0, fileName.lastIndexOf(\".\"))); imagesMap.put(fileName.substring(0, fileName.lastIndexOf(\".\")), getImageFromPath(\"/images/\" + fblpath + \"/\" + fileName));&#125; 核心 使用rgb进行颜色比对，判断图片是否包含，确定图片位置之后进行相对位置的定位1234567891011121314151617181920212223242526272829303132333435363738394041424344//查找图片private boolean findPic(BufferedImage screenShotImage, BufferedImage targetImage, String buttonName) &#123; int[][] screenImageData = getImageGRB(screenShotImage); int[][] targetImageData = getImageGRB(targetImage); int targetImageHeight = targetImage.getHeight(); int targetImageWidth = targetImage.getWidth(); int screenImageHeight = screenShotImage.getHeight(); int screenImageWidth = screenShotImage.getWidth(); //先根据上次的位置查找，找不到再遍历查找 int[] res = position.get(buttonName); if (res != null &amp;&amp; res.length == 4) &#123; boolean isFinded = isMatchAll(res[1], res[0], targetImageHeight, targetImageWidth, screenImageHeight, screenImageWidth, screenImageData, targetImageData); if (isFinded) &#123; int mouseX = res[0] + getNum(3, targetImageWidth); int mouseY = res[1] + getNum(3, targetImageHeight); position.put(buttonName, new int[]&#123;res[0], res[1], mouseX, mouseY&#125;); return true; &#125; &#125; //遍历屏幕截图像素点数据 for (int y = 0; y &lt; screenImageHeight - targetImageHeight; y++) &#123; for (int x = 0; x &lt; screenImageWidth - targetImageWidth; x++) &#123; //根据目标图的尺寸，得到目标图四个角映射到屏幕截图上的四个点， //判断截图上对应的四个点与图B的四个角像素点的值是否相同， //如果相同就将屏幕截图上映射范围内的所有的点与目标图的所有的点进行比较。 if (isSamePoint(targetImageData[0][0], screenImageData[y][x]) &amp;&amp; isSamePoint(targetImageData[0][targetImageWidth - 1], screenImageData[y][x + targetImageWidth - 1]) &amp;&amp; isSamePoint(targetImageData[targetImageHeight - 1][targetImageWidth - 1], screenImageData[y + targetImageHeight - 1][x + targetImageWidth - 1]) &amp;&amp; isSamePoint(targetImageData[targetImageHeight - 1][0], screenImageData[y + targetImageHeight - 1][x])) &#123; boolean isFinded = isMatchAll(y, x, targetImageHeight, targetImageWidth, screenImageHeight, screenImageWidth, screenImageData, targetImageData); //如果比较结果完全相同，则说明图片找到，填充查找到的位置坐标数据到查找结果数组。 if (isFinded) &#123; int mouseX = x + getNum(3, targetImageWidth); int mouseY = y + getNum(3, targetImageHeight); position.put(buttonName, new int[]&#123;x, y, mouseX, mouseY&#125;); return true; &#125; &#125; &#125; &#125; return false;&#125; 完善 目前已增加鬼王之宴、突破功能，择日有空再肝","categories":[{"name":"好奇尚异","slug":"好奇尚异","permalink":"https://www.kikfan.com/categories/好奇尚异/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.kikfan.com/tags/Java/"},{"name":"hobby","slug":"hobby","permalink":"https://www.kikfan.com/tags/hobby/"}]},{"title":"Mysql物理备份恢复","slug":"Mysql恢复","date":"2019-10-16T03:16:30.000Z","updated":"2019-10-24T03:13:46.000Z","comments":true,"path":"archives/29644176.html","link":"","permalink":"https://www.kikfan.com/archives/29644176.html","excerpt":"","text":"物理备份的恢复官方链接 存在问题，因为我们是要恢复到docker上的自建数据库，使用mysqld_safe命令启动，我们不好操作 其实只需要吧对应的数据指向容器的/var/lib/mysql 配置指向/etc/my.cnf即可 backup-my.cnf需要修改 123456789101112131415161718# This MySQL options file was generated by innobackupex.# The MySQL server[mysqld]#innodb_checksum_algorithm=innodb#innodb_log_checksum_algorithm=innodb#innodb_data_file_path=ibdata1:200M:autoextend#innodb_log_files_in_group=2#innodb_log_file_size=1048576000#innodb_fast_checksum=false#innodb_page_size=16384#innodb_log_block_size=512#innodb_undo_directory=.#innodb_undo_tablespaces=0#rds_encrypt_data=false#innodb_encrypt_algorithm=aes_128_ecb 如下为docker-compose.yml文件 12345678910111213141516version: '3.1'services: db: image: mysql:5.6 restart: always environment: MYSQL_ROOT_PASSWORD: 123456 command: --default-authentication-plugin=mysql_native_password --explicit_defaults_for_timestamp=true --lower_case_table_names=1 ports: - 3306:3306 volumes: - /home/mysql/data:/var/lib/mysql - /home/mysql/data/backup-my.cnf:/etc/my.cnf 自己测试数据库的备份和恢复，包括逻辑备份以及binlog的恢复mysqlbinlog的恢复 直接获取到的binlog的日志是通过base64加密的，需要查看的话，需要通过解密mysqlbinlog --base64-output=decode-rows -v mysql-bin.000001 通过position恢复的命令mysqlbinlog --start-position=&quot;230&quot; --stop-position=&quot;689&quot; binlog.000004 |mysql -uroot -p 通过时间点来进行恢复mysqlbinlog --start-datetime=&quot;2019-10-24 3:21:26&quot; --stop-datetime=&quot;2019-10-24 3:21:29&quot; binlog.000004 |mysql -uroot -p","categories":[{"name":"SQL","slug":"SQL","permalink":"https://www.kikfan.com/categories/SQL/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.kikfan.com/tags/SQL/"}]},{"title":"shell学习","slug":"shell学习","date":"2019-10-11T08:26:32.000Z","updated":"2019-10-11T08:26:32.000Z","comments":true,"path":"archives/f8d5cfbe.html","link":"","permalink":"https://www.kikfan.com/archives/f8d5cfbe.html","excerpt":"","text":"shell脚本学习 echo -e 不显示转义的字符 shell传递参数实例 1234567891011121314151617#!/bin/bash# author:菜鸟教程# url:www.runoob.comecho &quot;Shell 传递参数实例！&quot;;echo &quot;执行的文件名：$0&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;第二个参数为：$2&quot;;echo &quot;第三个参数为：$3&quot;;$ chmod +x test.sh $ ./test.sh 1 2 3Shell 传递参数实例！执行的文件名：./test.sh第一个参数为：1第二个参数为：2第三个参数为：3 $ 与 $@ 区别：相同点：都是引用所有参数。不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。 运算符eq：equal to。ne：not equal to。gt：greater than。ge：greater than or equal to。lt：less than。le：less than or equal to。 shell脚本还是有点意思，可以方便地传变量 shell里如果是赋值那么算式那么等号两边不能有空格而如果是进行比较等算式，则必须要有空格在两边 shell语句中的case when 用法 shell脚本求解一元二次方程不熟悉的东西，坑也是众多 1234567891011121314#!/bin/bashwhile read numsdo array=($nums) a=$&#123;array[0]&#125;;b=$&#123;array[1]&#125;;c=$&#123;array[2]&#125;# echo $a;echo $b;echo $c;tmp=$(scale=2;echo &quot;sqrt($b*$b-4*$a*$c)&quot;|bc);#echo $tmp;#echo &quot;scale=2;$b+$tmp&quot;|bcx1=$(echo &quot;scale=2;(-($b)+$tmp)/(2*$a)&quot;|bc)x2=$(echo &quot;scale=2;(-($b)-$tmp)/(2*$a)&quot;|bc)echo &quot;x1=$x1&quot;echo &quot;x2=$x2&quot;done","categories":[{"name":"好奇尚异","slug":"好奇尚异","permalink":"https://www.kikfan.com/categories/好奇尚异/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://www.kikfan.com/tags/shell/"}]},{"title":"K线形态分析程序","slug":"K线形态分析程序","date":"2019-09-29T10:26:42.000Z","updated":"2019-11-19T03:30:10.000Z","comments":true,"path":"archives/728ca17.html","link":"","permalink":"https://www.kikfan.com/archives/728ca17.html","excerpt":"欢迎访问","text":"Welcome, enter password to read this Incorrect Password! No content to display! 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","categories":[{"name":"好奇尚异","slug":"好奇尚异","permalink":"https://www.kikfan.com/categories/好奇尚异/"}],"tags":[{"name":"股票","slug":"股票","permalink":"https://www.kikfan.com/tags/股票/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2019-08-07T04:17:13.000Z","updated":"2019-08-07T04:17:13.000Z","comments":true,"path":"archives/d0edc1ed.html","link":"","permalink":"https://www.kikfan.com/archives/d0edc1ed.html","excerpt":"","text":"1.查看日志常用命令 tail: -n 是显示行号；相当于nl命令；例子如下： tail -100f test.log 实时监控100行日志 tail -n 10 test.log 查询日志尾部最后10行的日志; tail -n +10 test.log 查询10行之后的所有日志; head: 跟tail是相反的，tail是看后多少行日志；例子如下： head -n 10 test.log 查询日志文件中的头10行日志; head -n -10 test.log 查询日志文件除了最后10行的其他所有日志; cat： tac是倒序查看，是cat单词反写；例子如下： cat -n test.log |grep &quot;debug&quot; 查询关键字的日志 应用场景一：按行号查看—过滤出关键字附近的日志 cat -n test.log |grep “debug” 得到关键日志的行号 cat -n test.log |tail -n +92|head -n 20 选择关键字所在的中间一行. 然后查看这个关键字前10行和后10行的日志: tail -n +92表示查询92行之后的日志 head -n 20 则表示在前面的查询结果里再查前20条记录 应用场景二：根据日期查询日志 sed -n ‘/2014-12-17 16:17:20/,/2014-12-17 16:17:36/p’ test.log 特别说明:上面的两个日期必须是日志中打印出来的日志,否则无效； 先 grep &apos;2014-12-17 16:17:20&apos; test.log 来确定日志中是否有该 时间点 4.应用场景三：日志内容特别多，打印在屏幕上不方便查看 - 使用more和less命令, 如： cat -n test.log |grep &quot;debug&quot; |more 这样就分页打印了,通过点击空格键翻页 - 使用 &gt;xxx.txt 将其保存到文件中,到时可以拉下这个文件分析 如：cat -n test.log |grep &quot;debug&quot; &gt;debug.txt","categories":[{"name":"Java","slug":"Java","permalink":"https://www.kikfan.com/categories/Java/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.kikfan.com/tags/Linux/"}]},{"title":"背驰","slug":"背驰","date":"2019-07-08T15:30:45.000Z","updated":"2019-11-19T03:13:13.000Z","comments":true,"path":"archives/88ba48e.html","link":"","permalink":"https://www.kikfan.com/archives/88ba48e.html","excerpt":"欢迎访问","text":"Welcome, enter password to read this Incorrect Password! No content to display! U2FsdGVkX1+TJPyQtLEJ1EhPD4khAY8HcJNUuDKNSbT9kjOKwVOHTgLpD6MqYK+xkxnDgTCdgct6jcn2WE0ktz70Xp8p96lmHTbWLnByvyFTWvwt7+dBOIru7LssGbyIqrwNmAHsbBUdls2GFpvrd+ALBcMg/mNuUu4f8cMzl89dLLG0iUio461Qz0Y7R8+iPICLFFGyFgehQi9OVitUdi8ri7aFJ7g2NTvhG+n41tOiIv3rvXBF5xWHrLXdm4N4c0TfDrKAjpL/Plx1nFe7WNJ0grGYLUiNBqHN3G3gl2vrHFeIGzd1MuU96MxJe031BXp7h5WLFvFuZxhE4kqrNDjQGv/8TZUX1cv1ZL8qvjd5H2J5b+5HFqp53EJVplZDaXOkeN9KIAxoDEZV9Frft7QbZ8zWHEHFeKyhrMy6VjT52QC8EE+Jl2FUGq/pXZAK5c7qgNa/lcA9ylWMuMd8QsfvRFXaLCgXXopqCXN6UIsI5+TTGTOu3gdNDMrAwPxzyxUFfq5zO3CyrQVcX3rnl/JiPj1JTgg40aILIpPZNkraWFzy23atZbb4JAeGcCQqq0uBtq7oXI20BVcUkHcYzH7W5C/p6vXivIAeRXfh5S4KVp+fPTvrSX0jB0LrjoJz0M66PzPWdx2uvHbNh0ESYzh1bkgkr4XHB4mgboIJVIRdy7Us76kk+uBtwriw6p06udDs93hnhiCQN7DBRIsIHoO4q/hywNIam39TPeWwQ/98qkACsU3rCIrbuQs0lyVN7vwaYPqSRUcun0h2HmCy6tmN926e/CU/cD5Mqya1/2NzfJR6UceLb0osNj7dRO8howlT65KdOuJ9TCA04il5GlumzOilG8YdCdU/LpB9iczGjKm8CVQFqrNvuNPY9abRy+Q2YshAFAxLZ2/Di8f8LCBQy4rku4bNnhsWXuoNZFt851m/4xAa/JSATNcuBNwnq7cAaJd2ZhARQPG0qQKLMXcleRci7zQ9R5StmIIjou7pHGAKZNh6VjvobxrL/3XPCA/QqbpvjGe9gLhlOPiI2j7I7OgBM4WQWEEhopbXgGOni3+sjLsb2adQL1Lbcdbdb/GWnXT1mvwm9VGtsTPcIcNLngue6HLR6wA6iksOTmm40Cv01IP2Zakrr/TspH3xiPk+bwJ758takVCFXJcGSVT9y5hcX0vcLNp8vP/cbDG8J6wY06+qItgolWyM7JzGu68gzZufpul5sbnI61Sox2TeGondyHLKdhzySlwxat05bItRZFtd/JnCMrdVoQeQ4lBiNvwlVPL0eSPXLqZ3OTLR+FWOxErXAVuRsN0PYcvPIruOQNqv+lrp3jnVIjmbbXXfyKSZISMG4L2Je9xVisVjm5mzyOn1BqW6swMTdYL3u3rsjxCviK5jV9bElJR6NXDIhhI7YKdEeDphyNIy0dweI9St0DfwM1/8O79NPELG1wpest/L1BPRnszpV49U661afzF8Emty4tZjrjRXNA==","categories":[{"name":"股海浮沉","slug":"股海浮沉","permalink":"https://www.kikfan.com/categories/股海浮沉/"}],"tags":[{"name":"股票","slug":"股票","permalink":"https://www.kikfan.com/tags/股票/"}]},{"title":"日常小技巧","slug":"日常小技巧","date":"2019-06-05T06:42:17.000Z","updated":"2019-06-05T06:42:17.000Z","comments":true,"path":"archives/9dfc94f1.html","link":"","permalink":"https://www.kikfan.com/archives/9dfc94f1.html","excerpt":"","text":"Excel连接文本使用concatenate(text1,text2,text3…)函数，其中，如果有符号需要用双引号包裹例如 concatenate(“‘“,text1,”‘“)这种形式，主要是跑辅助sql的时候可以比较方便","categories":[{"name":"实用工具","slug":"实用工具","permalink":"https://www.kikfan.com/categories/实用工具/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://www.kikfan.com/tags/日常/"}]},{"title":"List排序","slug":"List排序","date":"2019-05-24T04:28:32.000Z","updated":"2019-06-21T03:10:25.000Z","comments":true,"path":"archives/b8b2cf67.html","link":"","permalink":"https://www.kikfan.com/archives/b8b2cf67.html","excerpt":"","text":"最近懈怠较重，急需正反馈 结合Lambda,初始list123456789101112131415@Testpublic void testLambda() &#123; List&lt;StudentCourse&gt; list = new ArrayList&lt;&gt;(); int[][] nums = new int[][]&#123;&#123;1, 4, 88&#125;, &#123;8, 4, 7&#125;, &#123;8, 2, 9&#125;, &#123;8, 2, 88&#125;&#125;; for (int i = 0; i &lt; nums.length; i++) &#123; StudentCourse course = new StudentCourse(); course.setSid(nums[i][0]); course.setCid(nums[i][1]); course.setScore(nums[i][2]); list.add(course); &#125; list.sort(Comparator.comparing(StudentCourse::getSid).reversed() .thenComparing((s1, s2) -&gt; s2.getCid().compareTo(s1.getCid())) .thenComparing(StudentCourse::getScore));&#125; 根据某个字段的值排序1list.sort((o1, o2) -&gt; o1.getCid().compareTo(o2.getCid())); 结合Comparator,注意可以使用reversed调转1list.sort(Comparator.comparing(StudentCourse::getSid).reversed()); 需要根据多个字段排序123list.sort(Comparator.comparing(StudentCourse::getSid).reversed() .thenComparing((s1, s2) -&gt; s2.getCid().compareTo(s1.getCid())) .thenComparing(StudentCourse::getScore)); 将A List的元素以B List的排序规则进行排序1entities.sort(Comparator.comparing((o) -&gt; bookIds.indexOf(o.getReadingBookId())));","categories":[{"name":"Java","slug":"Java","permalink":"https://www.kikfan.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.kikfan.com/tags/Java/"},{"name":"List","slug":"List","permalink":"https://www.kikfan.com/tags/List/"}]},{"title":"重启征程","slug":"重启征程","date":"2019-05-08T03:17:57.000Z","updated":"2019-11-19T03:13:03.000Z","comments":true,"path":"archives/188c91f.html","link":"","permalink":"https://www.kikfan.com/archives/188c91f.html","excerpt":"欢迎访问","text":"Welcome, enter password to read this Incorrect Password! No content to display! U2FsdGVkX1+WE5qFOzdNVIbVDO9ZA2tUVe6QAqokan6vK0ITu7vve44lqk9fc+uGnIQfvI165EDdTmkgmZTp99+NVDcEAOr8DfyI6dxg4EBtBNrvIflgE3Ijs+vwo4v1M9MtRZ2yKwB2sPVMs2mH6RKjnMuVlwK5W70DlCR7FNxR0WxP10azAu9JmL1AKQiIliCp2LRqgLkxhHibsz3jYlnHEwByfviA8yqBUS1qem7xVVfcCcs2fjLRvoxp5+vWtfv3yvO6j2ky0Tx2EDP1Hr7Lc43RkFWoaYj6JMevq3u/ltf2q2r1FT4Mf2vgW+T1aB8QpgpzOEjZJmH9ACX61XK9EIwefrEkx/LrJL3jcB/zxhn20OYrJlw7FbBrx6EPgXI1hPRLEEnkTJFQksyesguVnCewFzQHiXNodj61eZUgyWMcdSC9fZItF4rSTQjwCqbFU/Uj8XKo7T8rkvpAozGAKsxSu+Y3mAKIySm5kHrkS0rT4mSjUc8HPkuzKXUdpTjEkeD3na50VWtvjG/azUi9PAp8PltY4bA0PsBHOGSLm08ia8YNsQBMs6Um4DnxoggWtmXaFDsUaizHWepccSgdjCX1MpHr/7pP4bQp0SPaRUJ6ZLLZt4xCewc5FrHZwUzxlhE6FmVYBLko4kjMEyoQU+0td4+yxnVq9YzpORbenuVprRFr/AyOUFgdGA16","categories":[],"tags":[]},{"title":"密码与素数","slug":"密码与素数","date":"2019-04-19T06:09:06.000Z","updated":"2019-04-19T06:09:06.000Z","comments":true,"path":"archives/47e39252.html","link":"","permalink":"https://www.kikfan.com/archives/47e39252.html","excerpt":"","text":"转自: 密码学 密码学，一向被人们认为门槛很高，特别高端…这也是实际，但是这决不意味着普通人无法了解它的精髓，对于喜欢画圆的人来讲，即便是理解了密码技术背后的哪怕一点理论，也是激动人心的。 规则的抽象 我们小学的时候学习过四则混合运算，后来又将运算的作用范围扩大到了整个实数集 合，再后来又引入了虚数…实际上，这些都不重要，关键点在于运算法则本身。给定一个集合，如果集合内的任意元素在进行四则混合运算(要满足交换率，结 合率…)后的结果仍然在该集合内，如果该集合又是一个有限的集合，那么该集合就可以作为计算机上密码学使用的那个有限的框框。 如何来生成一个有限的集合，方法很多，最显而易见的就是“取模”，即对一个数字做除法然后取余数，比如如果我们将所有的正整数集合内的任意数字对数字5取 模，那么结果无非也就0，1，2，3，4这5个数，不管怎么样结果也跑不出这5个数，就算你用1000和1234相加，结果2234除以5所得的余数4， 也在这个范围内，这就是一个有限的集合，即我们说的那个有限的框框，计算机在这个集合里面做运算刚刚好，对于上一节所举的这个大数而言，任意正整数对它取 模便可以形成一个很大的集合，而计算机密码学的很多运算就是在这类集合内运转的。 到此为止，我们已经知道如何生成一个有限的集合来方便计算机进行任意的运算，但是光这还不够，因为我们仅仅定义了一些运算法则以及一个有限的集合，单位元 我们还没有，对于单位元而言，它可以作为集合内任意元素之间的媒介，事实上它是一个衡量的尺度，比如对于整数加法，单位元就是0，任何一个数字和0相加结 果都是它本身，通过单位元0还可以找到任意一个整数的相反数，与其相加的结果就是单位元，对于乘法而言也类似，乘法的单位元是1，而对应加法相反数的概念 则是倒数，不管是加法的相反数，还是乘法的倒数，都可以被称作逆元。那么对于取模的结果生成的集合内，有没有单位元呢？在回答这个问题之前，必须要声明的 一点就是：对于集合内的任意一个元素，都必须拥有逆元，这样整个集合才可能是闭合的，否则一旦让一个没有逆元的元素参与运算，结果将是不可预知的(跑飞 了…)。理解了这一点之后，我们就可以瞬间理解“为什么在密码学中素数这么重要”，“为什么循环群一定要有生成元”等问题。 为什么一定要素数 在密码学中，特别是公钥密钥学中，我们经常要面对生成一个大素数的问题，可是为什么一定要是素数呢？难道就是因为它数量比较少吗？No！难道因为它的分布不确定吗？No！那到底是为什么？ 我们再来看上面那个模5的运算，集合为{0,1,2,3,4}，对于乘法，我们看看每一个元素的逆元分别是什么，显然0的逆元不存在，而 11%5=1，23%5=1，32%5=1，44%5=1，这样除了0之外，其它的元素都有逆元，而我们注意到，模数5是一个素数…那么我们 把特殊的元素0抛弃，留下{1,2,3,4}作为我们需要的有限集合，是不是可以呢？当然可以！ 然而，我上面的论述有点以偏概全了，毕竟这只是一个特例。那么接下来就要证明一下这是一个普遍的结论：如果模数p为一个素数，那么对整个正整数集合取模的 结果去掉0就能生成一个乘法运算闭合的集合，该集合是个素域，集合中的元素数量是p-1(因为去掉了0。Oh yeah，这不就是朴素的欧拉函数吗？)。证明方法很简单。 假设一个集合N={1,2,3,4….p-1}，p为素数，对于其中任意一个元素a，用a去乘整个集合，得到一个新的集合N’= {1a%p,2a%p,3a%p,4a%p…(p-1)a%p}，我们只需要证明这个新的集合中的某一个元素为1即可。对于集合N而言，有 一个条件我们还没有用过，那就是p为素数！这是关键之关键！p为素数意味着集合N中所有的元素和p都是互素的，即它们没有公约数，同时这也意味着，N’中 的元素和p也是互素的(这很容易用反证法证明！)，再看，N集合和N’集合的元素数量是一致的，而N集合包含了到p为止的正整数全集，我没只需要证明N’ 集合中的元素两两不相等，就可以说明N’集合也是到p为止的正整数全集，从而证明N==N’！还是反证法，假设N’即集合中有ma%p==na%p， 其中m&gt;n，设m=rp+x1，n=sp+x2，则x1%p==x2%p，x1和x2均是小于p的数，可以证明m和n模p同余，由于m和n都小 于p，因此m==n，和假设不符。因此N==N’。 这能说明什么呢？这说明集合N’中包含数字1，也就是说对于任何一个N中的元素a，在集合N中均拥有一个元素和其乘积模p等于1，这就说明集合N中的每一 个元素的逆元都是存在的。这就是模数为素数的重要性质！那么，相反地，如果模数不为素数又如何呢？举一个反例即可，如果模数p=ab，即它的因数是 a，b，并且a和b均小于p，那么集合N={1,2,3,4…p-1}中的a和b将不存在逆元，因为它们除模数p的余数始终为0，而不是单位元1！ 显然，模数为素数的重要性质就是可以将集合框在一个范围内，在此范围内，四则混合运算照常如旧，乘法单位元1存在！这是模运算的恩惠，也许是上帝的恩惠， 数学如此之美！想想看，在实数范围内的四则混合运算与单位元，在素数模运算中，竟然如此一致，这就是抽象代数，实际上，抽象代数不是被发明的，而是被发现 的！ 乘法逆元-大数分解 在理解了基本理论后，我们来看一下逆元为何如此重要，简单的说，求逆元在算法上是一个规范性的操作， 比如使用辗转相除法等，然而对于模数p未知的情况下，却是一个在计算上不可能的问题。至于为什么不可能，请不要按照学子们的理论来考究，而要用收益/代价 均衡的理论来考虑。比如你破解一个算法花了30年，有意义吗？在学术环境下是有意义的，那好吧，如果你能把算法强度提高到破解它需要付出300年的时间， 你就可以拿到大奖了。 求逆元是一个甚是简便的做法，可以说是一个协议，试想，加密解密双方在没有任何交互的前提下，怎么知道如何操作。那么运算集中的操作就是协议了，比如就是 求逆元。那么安全性在哪体现？给你两堆沙子，你将它们混合在了一起，然后你能再将它们区分出来吗？这就是大数分解问题的隐喻，这就是有限集合模运算算法安 全性的保障！ 素数模数界定了一个有限的集合，提供了可计算性，大数分解提供了计算的单向性。 现在我们步入RSA算法，这是一种常规的非对称密钥算法。首先选择两个比较大的素数p和q，然后计算n=pq，接下来需要界定一个集合，该集合内全部都 是和n互素的数，显然n不是素数，这就意味着必须在集合N={1,2,3,4…n-1}中抛弃和n不互素的数字。那么剩下的集合N’中还剩下多少元素 呢？在进一步讨论之前，我先讲一下前提。 上一节我论述了，如果模数p是一个素数，那么集合{1,2,3,…p-1}构成一个有限集合N，可以用作非对称密钥学计算，那么推广一下，如果p不是 素数，那么这个集合该如何界定呢？结论是，在集合N中抛弃所有和数字p不互素的数。我们假设p=mn，其中m，n均为素数，那么集合 {1,2,3,4…mn-1}中有多少和p互素的数呢？很显然，这些不和p互素的数字分为两类，一类是m的倍数，另一类是n的倍数，m的倍数在集合 中是{m,2m,3m…(n-1)m}，而n的倍数则是{n,2n,3n…(m-1)n}，因此集合{1,2,3,4…p-1}中和p互素的 集合N中数字的数量一共有(p-1)-(n-1)-(m-1)=mn-m-n+1=(m-1)(n-1)。 上述集合N中元素都有逆元吗？答案是肯定的。证明方法和素域p中的元素都有逆元的证明是一样的。首先将待求逆元的元素乘以集合N中的每一个元素并对mn 取模，得到新集合N’，证明这个集N’合和集合N是相等的，因此里面必然有元素1。证明这个只需要两点，首先证明N‘中的元素都是和mn互素的(实际上 代表了全部的和mn互素的数字组成的集合)，其次证明它们两两不相等，这就可以说明两个集合是一样的。 上面的这个结论是极其重要的，毕竟RSA算法的最开始就是要选择两个大素数p，q，然后计算n=pq，并且计算m=(p-1)(q-1)，看看m是什 么，m就是集合{1,2,3…n-1}中和n互素的集合N中数字的数量！RSA的计算将全部在集合N中进行！实际上，前几步的选取大素数p，q以及计 算(p-1)*(q-1)只是界定了一个计算的集合而已。 RSA算法在界定了集合N之后，就会在N中选取一个数字e，显然e的逆元肯定是存在的！那么计算e的逆元，结果就是私钥d！公钥就是e以及n。 n是明确的，但是你很难得到p和q，这就是算法的根本。技术实现上的关键点是，这种算法之所以可行，完全是这些算法过程是建立在一个有限的集合的基础上， 在该集合中存在单位元，满足交换率，计算闭合性。到这里为止，我并没有提到群，环，域的概念，也没有给出任何的定义，定理。但是殊途同归，一个简单的规则 抽象的设想便可以推出基本上所有的定理，定义，只是我没有说哪些是定义，哪些是定理罢了。想了解这些，随便找一本数论，抽象代数的书你就可以学到。读了这 些书的结果如何呢？结果就是你可以拿起笔写下试题的答案，然而即便这样，如果不自己从头到尾的思考，你可能仍然不知所以然，只知道某某学科有一个XX定 理，它的证法是这样的… 这个简单的设想就是在一个集合中，其所有元素乘法逆元的存在性。要存在乘法逆元，素数便登上了舞台，因为我们发现，如果一个集合中的元素和模数均是互素 的，那么乘法逆元就一定存在，最简单的这种集合就是所谓的素域，当然对于模数是任意值的集合而言，欧拉函数给出了集合中元素的个数。请注意，欧拉函数“只 是一种找到元素个数的方法”，而和集合的本质没有太多的关系。 依然本着乘法逆元，我们来看一下它是怎么导出在有限集合中的离散对数问题的。 乘法逆元-离散对数问题 我 们依然看最初的那个集合N={1,2,3,4…p-1}，其中p为素数。现在我们知道这个集合中均存在乘法逆元，计算也都是闭合的。我们随便拿出该集 合的一个元素a，用它来乘以集合N中的每一个元素并模p，得到新的集合N’={1a%p,2a%p,3a%p,4a%p…(p- 1)a%p}，我们知道其中肯定有一个元素为1，对应的该元素去掉a后就是a的逆元。好的，一切正常，现在没有完，继续用a乘以集合N’中的元素并模 p得到N’’，我们知道N‘’和N是相等的，再进一步，用a去乘N‘’的每一个元素并模p得到N‘’‘，…N’‘’‘’我们可以得出，所有这些 N，N’，N’’，N’’’，N’’’’’…等都是相同的集合，因此我们就知道，a的不管多少次方模p的结果都在集合N内。 这个结论很重要，这显然又构成了一个闭合的运算集合，在该集合内，任意一个元素的任意次方模p的结果依然属于该集合，给定一个集合内的元素a以及另一个元 素b，你能算出a的多少次方模p等于b吗？这就是离散对数问题。显然，只有在模运算的情况下才绘出现如此多的有趣特性，显然，钟表上绕圈还是很好玩的。也 许你想知道离散对数问题和乘法逆元有什么关系，关系并不是那么明确，然而，一个集合中每一个元素逆元的存在则是必须的要求。如此好玩的在钟表上绕圈的规则 总结成一门学科就是数论，而密码学则是利用了数论的诸多定理和定义的学科。","categories":[{"name":"好奇尚异","slug":"好奇尚异","permalink":"https://www.kikfan.com/categories/好奇尚异/"}],"tags":[{"name":"密码","slug":"密码","permalink":"https://www.kikfan.com/tags/密码/"},{"name":"素数","slug":"素数","permalink":"https://www.kikfan.com/tags/素数/"}]},{"title":"Elasticsearch","slug":"Elasticsearch","date":"2019-03-27T02:19:12.000Z","updated":"2019-04-14T15:32:17.000Z","comments":true,"path":"archives/d32d37e5.html","link":"","permalink":"https://www.kikfan.com/archives/d32d37e5.html","excerpt":"","text":"安装ES1234567891011version: '3.3'services: elasticsearch: image: wutang/elasticsearch-shanghai-zone:6.3.2 container_name: elasticsearch restart: always ports: - 9200:9200 - 9300:9300 environment: cluster.name: elasticsearch 连接ES123456789101112131415@Testpublic void testElasticsearch() throws UnknownHostException &#123; Settings settings = Settings.builder() .put(\"cluster.name\", \"elasticsearch\") .put(\"client.transport.sniff\", false) .build(); TransportClient client = new PreBuiltTransportClient(settings); client.addTransportAddress(new TransportAddress(InetAddress.getByName(\"192.168.147.128\"),9300)); GetResponse response = client.prepareGet(\"accounts\", \"person\", \"1\").get(); System.out.println(response.toString());&#125;","categories":[{"name":"好奇尚异","slug":"好奇尚异","permalink":"https://www.kikfan.com/categories/好奇尚异/"}],"tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://www.kikfan.com/tags/Elasticsearch/"}]},{"title":"SQL战leetcode","slug":"SQL战leetcode","date":"2019-03-18T17:15:14.000Z","updated":"2019-03-19T18:15:23.000Z","comments":true,"path":"archives/7c4ba2e7.html","link":"","permalink":"https://www.kikfan.com/archives/7c4ba2e7.html","excerpt":"","text":"180.连续出现的数字1234567select distinct tmp.ConsecutiveNums from(select Num as ConsecutiveNums, case when @prev = Num then @count := @count+1 when @prev :=Num then @count :=1 end as count from Logs,(select @prev :=null,@count :=null) pc) tmp where tmp.count &gt;=3 其实不够严谨，没有考虑Num为0的情况，应当把when @prev :=Num then @count :=1改为when (@prev :=Num) is not null then @count :=1 184.部门工资最高的员工12345678select d.Name as Department,e.Name as Employee,e.Salaryfrom Employee e inner join Department d on e.DepartmentId = d.Idinner join(select DepartmentId,Max(Salary) as maxSalaryfrom Employeegroup by DepartmentId) tmpon e.DepartmentId = tmp.DepartmentId and e.Salary = tmp.maxSalary 178.分数排名1234567SELECT tmp.Score, CASE WHEN tmp.Score = @prev THEN convert(@rank,UNSIGNED ) WHEN (@prev := tmp.Score) is not null THEN convert(@rank := @rank + 1,UNSIGNED ) END AS RankFROM (SELECT Score FROM Scores ORDER BY Score DESC) tmp, (SELECT @prev := NULL, @rank := 0) pr 也是注意这里when后面的用法问题 12SELECT s1.Score,(SELECT count(DISTINCT s2.Score)+1 FROM Scores s2 WHERE s2.Score &gt;s1.Score ) as Rank FROM Scores s1 order by Score desc 子查询，看起来写法是简单了，但是实质上性能差了不少 177.第N高的薪水 要求如果不存在的话返回null 下方为自己的解法,判断null的问题居然还是多余的。。。 123456789101112CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN RETURN ( # Write your MySQL query statement below. select case when count(*) = 1 then Salary else null end from (select e.Salary,@rownum := @rownum + 1 as rownum from (select Salary from Employee group by Salary order by Salary desc) e,(select @rownum := 0) r) tmp where rownum = N );END 看起来简洁写法 12345678CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN # Write your MySQL query statement below. set N = N-1; RETURN ( select distinct ifnull(salary,null) from employee order by salary desc limit N,1 ); END 177.上升的温度123456select w1.Idfrom Weather w1 inner join Weather w2 # on w1.RecordDate = date_add(w2.RecordDate,interval 1 Day)on datediff(w1.RecordDate,w2.RecordDate) = 1and w1.Temperature &gt; w2.Temperature inner join当中，where和on的效果貌似没什么区别 176.第二高的薪水 这里就看出写法的问题了 12345678select case when count(*) = 1 then Salaryelse null end as SecondHighestSalaryfrom(select Salary,@rownum := @rownum + 1 as rownum from(select Salary from Employee group by Salary order by Salary desc) tmp,(select @rownum := 0) r) twhere rownum = 2 个人第二种解法 1234select case when count(*) &gt; 0 then Salaryelse null end as SecondHighestSalaryfrom Employee e1 where (select count(distinct Salary) from Employee e2 where e2.Salary &gt; e1.Salary) =1 丫的还有这种玩法,外面再套一层的方式 1234select IFNULL((select distinct(Salary) from Employeeorder by Salary desclimit 1,1),null) as SecondHighestSalary 需要第N高使用limit N-1,1是最直接的，如果没有需要返回null，那么在外面再套一层就是了262.行程和用户12345678select t.Request_at as Day,round((sum(case when t.Status &lt;&gt; 'completed' then 1 else 0 end)/count(*)),2) as 'Cancellation Rate'from Trips tinner join Users u on t.Client_Id = u.Users_Id and u.Banned = 'No'inner join Users u2 on t.Driver_Id = u2.Users_Id and u2.Banned = 'No'where t.Request_at between '2013-10-01' and '2013-10-03'group by t.Request_at order by t.Request_at asc 1.非禁止用户这是一个坑2.round的用法 196.删除重复的邮箱12345delete Person from Personleft join (select min(Id) as mIdfrom Person group by Email ) tmpon Id = tmp.mId where tmp.mId is null 亦可使用该种方式 12delete p1 from Person p1 ,Person p2where p1.Email =p2.Email and p1.Id &gt; p2.Id delete 后面的table不能使用别名 扩展，delete连表的语句 不可别名或者使用了别名需要别名对应 USING的使用123DELETE t1 FROM t1 LEFT JOIN T2 ON t1.id=t2.id WHERE t2.id IS NULL DELETE FROM t1 USING t1 LEFT JOIN T2 ON t1.id=t2.id WHERE t2.id IS NULL 185.部门工资前三高的员工1234567select d.Name as Department, e.Name as Employee,e.Salaryfrom Employee e inner join Department don e.DepartmentId = d.Idwhere (select count(distinct e2.Salary) from Employee e2 where e.DepartmentId = e2.DepartmentId and e2.Salary &gt; e.Salary)&lt; 3 order by d.Id asc,e.Salary desc where条件和所选的字段其实都是可以使用该种子查询的方式的 1234567891011select d.Name as Department, tmp.Name as Employee,tmp.Salaryfrom(select e1.Name,e1.Salary,e1.DepartmentIdfrom Employee e1 inner join Employee e2 on e1.DepartmentId = e2.DepartmentIdwhere e2.Salary &gt;= e1.Salarygroup by e1.Id having count(distinct e2.Salary) &lt;=3) tmpinner join Department don tmp.DepartmentId = d.Idorder by d.Id asc,tmp.Salary desc 使用了group by和having的处理方式，效率方面更高，可以看出子查询的局限性 601.体育馆的人流量 初步想法，用到了find_in_set这个函数 1234567891011select stadium.* from stadium,(select group_concat(t.id) as idsfrom(select tmp.*,@rownum := @rownum + 1,tmp.id - @rownum as diff from(select *from stadium where people &gt;=100) tmp,(select @rownum := 0) r) tgroup by diff having count(*) &gt;=3) ttwhere find_in_set(id,tt.ids) &gt;0 也可以使用min和max然后使用between and的方式 627.交换性别1update salary set sex = if(sex = 'm','f','m') 简单题，考察sql里面if的用法","categories":[{"name":"SQL","slug":"SQL","permalink":"https://www.kikfan.com/categories/SQL/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.kikfan.com/tags/SQL/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.kikfan.com/tags/leetcode/"}]},{"title":"frp实现内网穿透","slug":"frp实现内网穿透","date":"2019-03-16T02:23:33.000Z","updated":"2019-03-16T18:37:22.000Z","comments":true,"path":"archives/f51df9f4.html","link":"","permalink":"https://www.kikfan.com/archives/f51df9f4.html","excerpt":"","text":"什么是frpfrp 是一个高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务，支持 tcp, http, https 等协议类型，并且 web 服务支持根据域名进行路由转发。 准备在使用frp之前，需要一台有公网IP的服务器（下文称外网主机），一台需要实现内网穿透的机器（下文称内网主机），SSH工具，以及一个域名（如果只是建立SSH反向代理则不需要域名）。该文章中笔者所使用的服务器是朋友推荐的Vultr服务器，虽然服务器是在国外，但胜在带宽够，有需要的朋友可以注册一个。而需要实现内网穿透的机器则是笔者用上网本搭建的黑。SSH工具使用的是Xshell 5。而域名笔者则是使用自己个人网站的域名。开始使用根据机器的操作系统，在Release页面中找到对应的frp程序，然后分别在外网主机和内网主机中下载它。下面的所示范用的frp程序版本是以笔者的服务器为主的。外网主机SSH连接上外网主机后，使用wget指令下载frp。1wget https://github.com/fatedier/frp/releases/download/v0.20.0/frp_0.20.0_linux_amd64.tar.gz 使用tar指令解压tar.gz文件1tar -zxvf frp_0.20.0_linux_amd64.tar.gz 使用cd指令进入解压出来的文件夹1cd frp_0.20.0_linux_amd64/ 外网主机作为服务端，可以删掉不必要的客户端文件，使用rm指令删除文件。12rm -f frpcrm -f frpc.ini 接下来要修改服务器配置文件，即frps.ini文件。使用vi指令对目标文件进行编辑。1vi frps.ini 打开frps.ini后可以看到默认已经有很多详细的配置和示范样例，该文章仅以达到内网穿透为目的，所以这里选择删掉或注释掉里面的所有内容，然后根据的情况，按照官方的中文文档添加以下配置。（这里的操作都使用vi命令，关于vi命令的使用方式这里不作详细介绍，可以自行搜索相关使用方法。）12bind_port = 7000vhost_http_port = 8080 [common][common]部分是必须有的配置，其中bind_port是自己设定的frp服务端端口，vhost_http_port是自己设定的http访问端口。保存上面的配置后，使用以下指令启动frp服务端。（如果需要在后台运行，请往下翻阅关于后台运行的部分。）1./frps -c ./frps.ini 服务端的工作就到此结束了。 客户端客户端前面的操作和服务端是一模一样的，这里不一一解释。123456wget https://github.com/fatedier/frp/releases/download/v0.20.0/frp_0.20.0_linux_amd64.tar.gztar -zxvf frp_0.20.0_linux_amd64.tar.gzcd frp_0.20.0_linux_amd64rm -f frpsrm -f frps.inivi frpc.ini 客户端的配置如下12345678910111213141516171819[common]server_addr = x.x.x.xserver_port = 7000[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000[nas]type = httplocal_port = 5000custom_domains = no1.sunnyrx.com[web]type = httplocal_port = 80custom_domains = no2.sunnyrx.com 上面的配置和服务端是对应的。[common]中的server_addr填frp服务端的ip（也就是外网主机的IP），server_port填frp服务端的bind_prot。[ssh]中的local_port填的ssh端口。[nas]中的type对应服务端配置。local_port填的DSM端口。custom_domains为要映射的域名，记得域名的A记录要解析到外网主机的IP。[web]同上，local_port填的web端口。这里创建了两个http反向代理是为了分别映射两个重要的端口，5000和80，前者用于登录管理，后者用于的Web Station和DS Photo。保存配置，输入以下指令运行frp客户端。（同样如果需要在后台运行，请往下翻阅关于后台运行的部分。）1./frpc -c ./frpc.ini 此时在服务端会看到”start proxy sucess”字样，即连接成功。现在可以用SSH通过外网主机IP:6000和建立SSH连接。通过浏览器访问no1.sunnyrx.com:8080打开nas的管理页面，访问no2.sunnyrx.com:8080打开Web Station的网站，DS Photo app可以连接no2.sunnyrx.com:8080进入DS Photo管理。 让frp在后台运行虽然现在frp运作起来了，内网穿透也实现了，但这还是不够的。此时如果断开与服务端或者客户端的SSH连接（比如关掉了Xshell）也就中止了frp的运行。保持frp运行是关键是让服务端的frp和客户端的frp在后台运行，这里提两个方法供参考，一个是使用screen指令，另一个是使用nohup指令。由于的系统默认是没有screen指令的，这里也不提供安装screen的方法，所以推荐直接使用nohup。 其实服务端也直接用’nohup’就好了。 使用nohup指令nohup指令的使用方法相对简单，只需要在nohup后面加上frp的运行指令即可。下面示范的指令是运行frp客户端。（同样，如果之前断开了SSH连接，记得用cd指令进入frp的目录先。）1nohup ./frpc -c ./frpc.ini &amp; 这样就成功让frp在后台运行了。 原文链接 GitHub ngrok自建服务器穿透 ngrok","categories":[{"name":"好奇尚异","slug":"好奇尚异","permalink":"https://www.kikfan.com/categories/好奇尚异/"}],"tags":[{"name":"frp","slug":"frp","permalink":"https://www.kikfan.com/tags/frp/"},{"name":"内网穿透","slug":"内网穿透","permalink":"https://www.kikfan.com/tags/内网穿透/"}]},{"title":"集合的求交集方法测试","slug":"集合的求交集方法测试","date":"2019-03-08T16:31:18.000Z","updated":"2019-03-08T16:31:18.000Z","comments":true,"path":"archives/b0026423.html","link":"","permalink":"https://www.kikfan.com/archives/b0026423.html","excerpt":"","text":"猜想 心血来潮，也是有需要使用到集合的交集，对List的Stream求交集，retainAll求交集，以及guava的求交集方式进行了测试1234567891011121314151617181920212223242526@Testpublic void testGuava()&#123; String a = \"1,7,3\"; String b = \"2,5,8\"; int num = 20000; for (int i = 0; i &lt;num ; i++) &#123; a = String.format(\"%s,%s\",a,(int) (Math.random() * num)); b = String.format(\"%s,%s\",b,(int) (Math.random() * num)); &#125; String[] arrayA = a.split(\",\"); String[] arrayB = b.split(\",\"); Set&lt;String&gt; setA = Arrays.stream(arrayA).collect(Collectors.toSet()); Set&lt;String&gt; setB = Arrays.stream(arrayB).collect(Collectors.toSet()); List&lt;String&gt; listA = Arrays.stream(arrayA).distinct().collect(Collectors.toList()); List&lt;String&gt; listB = Arrays.stream(arrayB).distinct().collect(Collectors.toList()); long l = System.currentTimeMillis(); System.out.println(listA.stream().filter(listB::contains).collect(Collectors.toList()).size()); long l1 = System.currentTimeMillis(); System.out.println(String.format(\"%s个数字：stream方法耗时：%s\",num,l1-l)); System.out.println(Sets.intersection(setA, setB).size()); long l2 = System.currentTimeMillis(); System.out.println(String.format(\"%s个数字：Guava方法耗时：%s\",num,l2-l1)); listA.retainAll(listB); System.out.println(listA.size()); System.out.println(String.format(\"%s个数字：retainAll方法耗时：%s\",num,System.currentTimeMillis()-l2));&#125; 测试结果123456203500个数字：stream方法耗时：4203500个数字：Guava方法耗时：38203500个数字：retainAll方法耗时：2 12345620135000个数字：stream方法耗时：7020135000个数字：Guava方法耗时：3720135000个数字：retainAll方法耗时：32 123456808220000个数字：stream方法耗时：777808220000个数字：Guava方法耗时：31808220000个数字：retainAll方法耗时：771 结论 在数据的规模小的时候，使用List的Stream方法和retainAll效率更高，但当数据量大了之后，Guava的方法就拉开了一个档次","categories":[{"name":"Java","slug":"Java","permalink":"https://www.kikfan.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.kikfan.com/tags/Java/"},{"name":"集合","slug":"集合","permalink":"https://www.kikfan.com/tags/集合/"}]},{"title":"MySQL，一叶障目，不见泰山","slug":"一叶障目，不见泰山","date":"2019-02-26T16:01:48.000Z","updated":"2019-06-20T08:57:54.000Z","comments":true,"path":"archives/5bea5d90.html","link":"","permalink":"https://www.kikfan.com/archives/5bea5d90.html","excerpt":"","text":"过于草率地相信直觉的判断了，作为一个猜想是需要验证的，想当然才是根源 执行力不够，脑袋里产生想法之后一定要立即马上去验证，时间长了就忘了！！（最次也得上备忘录） 对于连表的理解有欠缺 sql语句多学多看，多查，终身学习，不要被其他的边边角角占据了头脑，保持敏锐！ 对于where in和inner join，not in 和left join之间的转化关系有进一步了解 前几名的问题，使用group_concat 和 find_in_set的形式可以方便地解决问题 周的生日的问题，年份必须转化，不然只会是错误的结果 case when 的用法，常见于行和列的转化 MySQL里没有排名函数，所以使用定义的方式就尤为重要，尤其是不保留排名的方式，必须要3个变量 Update Join12345update table_name_1inner join table_name_2 on table_name_1.id = table_name_2.uidinner join table_name_3 on table_name_3.id = table_name_1.tidset *** = ***where *** Delete Join123DELETE a FROM t1 a LEFT JOIN (SELECT min(info_id) AS infoIdFROM t1GROUP BY form_id) b ON a.info_id = b.infoId WHERE b.infoId is NULL in 和 existsin是把外表和内表作hash连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询，一直以来认为exists比in效率高的说法是不准确的。如果查询的两个表大小相当，那么用in和exists差别不大；如果两个表中一个较小一个较大，则子查询表大的用exists，子查询表小的用in； 例如：表A(小表)，表B(大表) select * from A where cc in(select cc from B) –&gt;效率低，用到了A表上cc列的索引； select * from A where exists(select cc from B where cc=A.cc) –&gt;效率高，用到了B表上cc列的索引。相反的： select * from B where cc in(select cc from A) –&gt;效率高，用到了B表上cc列的索引 select * from B where exists(select cc from A where cc=B.cc) –&gt;效率低，用到了A表上cc列的索引。 not in 和not existsnot in 逻辑上不完全等同于not exists，如果你误用了not in，小心你的程序存在致命的BUG，请看下面的例子： create table #t1(c1 int,c2 int); create table #t2(c1 int,c2 int); insert into #t1 values(1,2); insert into #t1 values(1,3); insert into #t2 values(1,2); insert into #t2 values(1,null); select * from #t1 where c2 not in(select c2 from #t2); –&gt;执行结果：无 select * from #t1 where not exists(select 1 from #t2 where #t2.c2=#t1.c2) –&gt;执行结果：1 3 正如所看到的，not in出现了不期望的结果集，存在逻辑错误。如果看一下上述两个select 语句的执行计划，也会不同，后者使用了hash_aj，所以，请尽量不要使用not in(它会调用子查询)，而尽量使用not exists（它会调用关联子查询）。如果子查询中返回的任意一条记录含有空值，则查询将不返回任何记录。如果子查询字段有非空限制，这时可以使用not in，并且可以通过提示让它用hasg_aj或merge_aj连接。 如果查询语句使用了not in，那么对内外表都进行全表扫描，没有用到索引；而not exists的子查询依然能用到表上的索引。所以无论哪个表大，用not exists都比not in 要快。 说多了都是泪啊 获取表中某字段包含某字符串的数据1SELECT * FROM `表名` WHERE LOCATE('关键字', 字段名) locate函数的用法 连续范围的问题123456789101112131415161718192021222324# 创建测试表CREATE TABLE `test_number` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `number` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '数字', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;# 创建测试数据insert into test_number values(1,1);insert into test_number values(2,2);insert into test_number values(3,3);insert into test_number values(4,5);insert into test_number values(5,7);insert into test_number values(6,8);insert into test_number values(7,10);insert into test_number values(8,11);SELECT min(number) start_range, max(number) end_rangeFROM (SELECT number, rn, number - rn diff FROM (SELECT number, @number := @number + 1 rn FROM test_number, (SELECT @number := 0) AS number) b) cGROUP BY diff; 签到问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141# 创建参考表(模拟数据需要用到)CREATE TABLE `test_nums` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='参考表';# 模拟数据，插入 1-1000 连续数据.create PROCEDURE test() BEGIN DECLARE i int DEFAULT 1; WHILE (i &lt; 1000) DO INSERT INTO test_nums VALUES (i); SET i = i + 1; END WHILE; END;CALL test();DROP PROCEDURE test;# 创建测试表CREATE TABLE `test_sign_history` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `uid` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '用户ID', `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '签到时间', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='签到历史表';# 创建测试数据insert into test_sign_history(uid,create_time)select ceil(rand()*10000),str_to_date('2016-12-11','%Y-%m-%d')+interval ceil(rand()*10000) minutefrom test_nums where id&lt;500;# 统计每天的每小时用户签到情况SELECT tmp.h, sum(CASE WHEN tmp.d = '20161211' THEN tmp.c ELSE 0 END ) as 11sign, sum(CASE WHEN tmp.d = '20161212' THEN tmp.c ELSE 0 END ) as 12sign, sum(CASE WHEN tmp.d = '20161213' THEN tmp.c ELSE 0 END ) as 13sign, sum(CASE WHEN tmp.d = '20161214' THEN tmp.c ELSE 0 END ) as 14sign, sum(CASE WHEN tmp.d = '20161215' THEN tmp.c ELSE 0 END ) as 15sign, sum(CASE WHEN tmp.d = '20161216' THEN tmp.c ELSE 0 END ) as 16sign, sum(CASE WHEN tmp.d = '20161217' THEN tmp.c ELSE 0 END ) as 17signFROM(select hour(create_time) h,date_format(create_time,'%Y%m%d') as d,count(*) cFROM test_sign_history group BY h,d) tmpGROUP BY tmp.h ORDER BY tmp.h;# 统计每天的每小时用户签到情况(当某个小时没有数据时，显示0)# 主要在于使用了辅助表，使用它用来作为left join 的主表SELECT tmp.h, sum(CASE WHEN tmp.d = '20161211' THEN tmp.c ELSE 0 END ) as 11sign, sum(CASE WHEN tmp.d = '20161212' THEN tmp.c ELSE 0 END ) as 12sign, sum(CASE WHEN tmp.d = '20161213' THEN tmp.c ELSE 0 END ) as 13sign, sum(CASE WHEN tmp.d = '20161214' THEN tmp.c ELSE 0 END ) as 14sign, sum(CASE WHEN tmp.d = '20161215' THEN tmp.c ELSE 0 END ) as 15sign, sum(CASE WHEN tmp.d = '20161216' THEN tmp.c ELSE 0 END ) as 16sign, sum(CASE WHEN tmp.d = '20161217' THEN tmp.c ELSE 0 END ) as 17signFROM (SELECT b.h,tsh.d,tsh.c FROM (SELECT id as h FROM test_nums WHERE id &lt;= 24) b LEFT JOIN (select hour(create_time) h,date_format(create_time,'%Y%m%d') as d,count(*) c FROM test_sign_history group BY h,d) tsh ON b.h = tsh.h ) tmpGROUP BY tmp.h ORDER BY tmp.h;# 统计每天的用户签到数据和每天的增量数据# 自己想的写法SELECT t.d, t.cnt, t.cnt - @rown AS increase, @rown := t.cntFROM (SELECT date_format(create_time, '%Y%m%d') AS d, count(*) AS cnt FROM test_sign_history GROUP BY d ORDER BY d) t, (SELECT @rown := 0) r;# 参考写法# 两种写法，思想不同而已SELECT type, sum(CASE WHEN create_time = '2016-12-11' THEN c ELSE 0 END) 11Sign, sum(CASE WHEN create_time = '2016-12-12' THEN c ELSE 0 END) 12Sign, sum(CASE WHEN create_time = '2016-12-13' THEN c ELSE 0 END) 13Sign, sum(CASE WHEN create_time = '2016-12-14' THEN c ELSE 0 END) 14Sign, sum(CASE WHEN create_time = '2016-12-15' THEN c ELSE 0 END) 15Sign, sum(CASE WHEN create_time = '2016-12-16' THEN c ELSE 0 END) 16Sign, sum(CASE WHEN create_time = '2016-12-17' THEN c ELSE 0 END) 17SignFROM (SELECT b.create_time, ifnull(b.c - c.c, 0) c, 'Increment' type FROM (SELECT date_format(create_time, '%Y-%m-%d') create_time, count(*) c FROM test_sign_history GROUP BY date_format(create_time, '%Y-%m-%d')) b LEFT JOIN (SELECT date_format(create_time, '%Y-%m-%d') create_time, count(*) c FROM test_sign_history GROUP BY date_format(create_time, '%Y-%m-%d')) c ON (b.create_time = c.create_time + INTERVAL 1 DAY) UNION ALL SELECT date_format(create_time, '%Y-%m-%d') create_time, count(*) c, 'Current' FROM test_sign_history GROUP BY date_format(create_time, '%Y-%m-%d')) aGROUP BY typeORDER BY CASE WHEN type = 'Current' THEN 1 ELSE 0 END DESC;#模拟不同的用户签到了不同的天数insert into test_sign_history(uid,create_time)select uid,create_time + interval ceil(rand()*10) day from test_sign_history,test_numswhere test_nums.id &lt;10 order by rand() limit 150;# 统计签到天数相同的用户数量SELECT date_format(create_time,'%Y%m%d') as d,count(DISTINCT uid) AS user_cntFROM test_sign_history GROUP BY d ORDER BY d;# 统计每个用户的连续签到时间# 属于连续问题的解决办法SELECT tmp2.uid,max(tmp2.sign_last) FROM ( SELECT tmp.uid, min(d) AS begin_date, max(d) AS end_date, datediff(max(d), min(d)) + 1 AS sign_last FROM (SELECT ud.uid, ud.d, datediff(ud.d, @time) AS diff, @time := @time + INTERVAL 1 DAY FROM (SELECT uid, date_format(create_time, '%Y-%m-%d') AS d FROM test_sign_history GROUP BY uid, d ORDER BY uid, d) ud, (SELECT @time := '2016-01-01') t) tmp GROUP BY tmp.uid, tmp.diff ) tmp2 GROUP BY tmp2.uid;# 参考写法SELECT *FROM (SELECT d.*, @ggid := @cggid, @cggid := d.uid, if(@ggid = @cggid, @grank := @grank + 1, @grank := 1) grank FROM (SELECT uid, min(c.create_time) begin_date, max(c.create_time) end_date, count(*) count FROM (SELECT b.*, @gid := @cgid, @cgid := b.uid, if(@gid = @cgid, @rank := @rank + 1, @rank := 1), b.diff - @rank as flag FROM (SELECT DISTINCT uid, date_format(create_time, '%Y-%m-%d') create_time, datediff(create_time, now()) diff FROM test_sign_history ORDER BY uid, create_time) b, (SELECT @gid := 1, @cgid := 1, @rank := 1) AS a) c GROUP BY uid, flag ORDER BY uid, count(*) DESC) d, (SELECT @ggid := 1, @cggid := 1, @grank := 1) AS e)fWHERE grank = 1; MySQL2 MySQL的测试表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263create table if not exists student( s_id varchar (20), s_name varchar (20) not null default '', s_birth varchar (20)not null default '', s_sex varchar (10) not null default '', primary key (s_id)) ;create table course( c_id varchar (20), c_name varchar (20)not null default '', t_id varchar (20)not null default '', primary key( c_id));create table teacher( t_id varchar (20), t_name varchar (20)not null default '', primary key (t_id));create table score( s_id varchar (20), c_id varchar (20), s_score int(3), primary key (s_id,c_id));insert into Student values('01' , '赵雷' , '1990-01-01' , '男');insert into Student values('02' , '钱电' , '1990-12-21' , '男');insert into Student values('03' , '孙风' , '1990-05-20' , '男');insert into Student values('04' , '李云' , '1990-08-06' , '男');insert into Student values('05' , '周梅' , '1991-12-01' , '女');insert into Student values('06' , '吴兰' , '1992-03-01' , '女');insert into Student values('07' , '郑竹' , '1989-07-01' , '女');insert into Student values('08' , '王菊' , '1990-01-20' , '女');insert into Course values('01' , '语文' , '02');insert into Course values('02' , '数学' , '01');insert into Course values('03' , '英语' , '03');insert into Teacher values('01' , '张三');insert into Teacher values('02' , '李四');insert into Teacher values('03' , '王五');insert into Score values('01' , '01' , 80);insert into Score values('01' , '02' , 90);insert into Score values('01' , '03' , 99);insert into Score values('02' , '01' , 70);insert into Score values('02' , '02' , 60);insert into Score values('02' , '03' , 80);insert into Score values('03' , '01' , 80);insert into Score values('03' , '02' , 80);insert into Score values('03' , '03' , 80);insert into Score values('04' , '01' , 50);insert into Score values('04' , '02' , 30);insert into Score values('04' , '03' , 20);insert into Score values('05' , '01' , 76);insert into Score values('05' , '02' , 87);insert into Score values('06' , '01' , 31);insert into Score values('06' , '03' , 34);insert into Score values('07' , '02' , 89);insert into Score values('07' , '03' , 98); 查询”01”课程比”02”课程成绩高的学生的信息及课程分数 考虑02课程没选的的情况SELECTs.*,sc.s_score AS 01score,sc2.s_score AS 02score FROM student s INNER JOIN score sc ON s.s_id = sc.s_id AND sc.c_id = ‘01’LEFT JOIN score sc2 ON s.s_id = sc2.s_id AND sc2.c_id = &apos;02&apos; WHERE sc.s_score &lt; sc2.s_score OR sc.s_score is NULL ; SELECT student.*, a.s_score AS 01_score, b.s_score AS 02_scoreFROM student JOIN score a ON student.s_id = a.s_id AND a.c_id = ‘01’ LEFT JOIN score b ON student.s_id = b.s_id AND b.c_id = ‘02’ OR b.c_id = NULLWHERE a.s_score &gt; b.s_score; 查询”01”课程比”02”课程成绩低的学生的信息及课程分数SELECT student.*, a.s_score AS 01_score, b.s_score AS 02_scoreFROM student JOIN score a ON student.s_id = a.s_id AND a.c_id = ‘01’ OR a.c_id = NULL LEFT JOIN score b ON student.s_id = b.s_id AND b.c_id = ‘02’WHERE a.s_score &lt; b.s_score; 查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩 group by 之后，如果已经group by 了用以区分的id,那么其他所有的属性都是可以直接得出来的SELECTs.s_id,s.s_name,round(avg(sc.s_score),1) as avg_score FROM student s LEFT JOIN score sc on s.s_id = sc.s_idGROUP BY s.s_id,s.s_name HAVING avg(sc.s_score) &gt;= 60; SELECT student.s_id, student.s_name, tmp.avg_scoreFROM student JOIN (SELECT score.s_id, round(avg(score.s_score), 1)AS avg_score FROM score GROUP BY s_id)AS tmp ON tmp.avg_score &gt;= 60WHERE student.s_id = tmp.s_id; –答案2 SELECT student.s_id, student.s_name, round(avg(score.s_score), 1) AS avg_scoreFROM student JOIN score ON student.s_id = score.s_idGROUP BY score.s_idHAVING avg(score.s_score) &gt;= 60; 查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩– (包括有成绩的和无成绩的)SELECT s.s_id,s.s_name,ifnull(round(avg(sc.s_score),1),0) as avg_scoreFROM student s LEFT JOIN score sc on s.s_id = sc.s_idGROUP BY s.s_id,s.s_name HAVING avg(sc.s_score) &lt; 60 or count(sc.s_score) = 0; SELECT student.s_id, student.s_name, tmp.avg_scoreFROM student JOIN (SELECT score.s_id, round(avg(score.s_score), 1)AS avg_score FROM score GROUP BY s_id)AS tmp ON tmp.avg_score &lt; 60WHERE student.s_id = tmp.s_idUNIONSELECT s_id, s_name, 0 AS avg_scoreFROM studentWHERE s_id NOT IN (SELECT DISTINCT s_id FROM score); –答案2 SELECT student.s_id, student.s_name, round(avg(score.s_score), 1) AS avg_scoreFROM student JOIN score ON student.s_id = score.s_idGROUP BY score.s_idHAVING avg(score.s_score) &lt; 60UNIONSELECT s_id, s_name, 0 AS avg_scoreFROM studentWHERE s_id NOT IN (SELECT DISTINCT s_id FROM score); 查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩SELECT s.s_id,s.s_name,count(DISTINCT sc.c_id) as num,sum(sc.s_score) as totalFROM student s LEFT JOIN score sc ON s.s_id = sc.s_idGROUP BY s.s_id ORDER BY total DESC ; SELECT student.s_id, student.s_name, count(score.c_id) AS total_count, sum(score.s_score)AS total_scoreFROM student LEFT JOIN score ON student.s_id = score.s_idGROUP BY student.s_id ORDER BY total_score DESC ; 查询”李”姓老师的数量SELECT count(1)FROM teacherWHERE t_name LIKE ‘李%’; 查询学过”张三”老师授课的同学的信息– 这就是因为对于连表的概念还不够融汇贯通的表现SELECT student.*FROM student INNER JOIN (SELECT sc.s_id FROM score sc INNER JOIN course c ON sc.c_id = c.c_id INNER JOIN teacher t ON c.t_id = t.t_id WHERE t.t_name= ‘张三’) tmp ON student.s_id = tmp.s_id; SELECT student.*FROM student INNER JOIN score sc ON student.s_id = sc.s_id INNER JOIN course c ON sc.c_id = c.c_id INNER JOIN teacher t ON c.t_id = t.t_id WHERE t.t_name= ‘张三’; SELECT *FROM student JOIN score ON student.s_id = score.s_idWHERE score.c_id IN (SELECT course.c_id FROM course WHERE course.t_id IN (SELECT teacher.t_id FROM teacher WHERE teacher.t_name = ‘张三’)); –答案2 SELECT student.*FROM student JOIN score ON student.s_id = score.s_id JOIN course ON course.c_id = score.c_id JOIN teacher ON course.t_id = teacher.t_id AND t_name = ‘张三’; 查询没学过”张三”老师授课的同学的信息SELECT *FROM studentWHERE s_id NOT IN (SELECT score.s_id FROM score WHERE score.c_id IN (SELECT course.c_id FROM course WHERE course.t_id = (SELECT teacher.t_id FROM teacher WHERE teacher.t_name = ‘张三’))); SELECT student.*FROM student LEFT JOIN (SELECT sc.s_id FROM score sc INNER JOIN course c ON sc.c_id = c.c_id INNER JOIN teacher t ON c.t_id = t.t_id WHERE t.t_name= ‘张三’) tmp ON student.s_id = tmp.s_id WHERE tmp.s_id is NULL ; –答案2 SELECT student.*FROM student LEFT JOIN (SELECT s_id FROM score JOIN course ON course.c_id = score.c_id JOIN teacher ON course.t_id = teacher.t_id AND t_name = ‘张三’)tmp ON student.s_id = tmp.s_idWHERE tmp.s_id IS NULL; 查询学过编号为”01”并且也学过编号为”02”的课程的同学的信息SELECT *FROM studentWHERE s_id IN (SELECT s_id FROM score WHERE c_id = 1) AND s_id IN (SELECT s_id FROM score WHERE c_id = 2); 查询学过编号为”01”但是没有学过编号为”02”的课程的同学的信息SELECT *FROM studentWHERE s_id IN (SELECT s_id FROM score WHERE c_id = 1) AND s_id NOT IN (SELECT s_id FROM score WHERE c_id = 2); –答案2 SELECT student.*FROM student JOIN (SELECT s_id FROM score WHERE c_id = 1)tmp1 ON student.s_id = tmp1.s_id LEFT JOIN (SELECT s_id FROM score WHERE c_id = 2)tmp2 ON student.s_id = tmp2.s_idWHERE tmp2.s_id IS NULL; 查询没有学全所有课程的同学的信息SELECT *FROM studentWHERE s_id NOT IN (SELECT s_id FROM score GROUP BY s_id HAVING count(c_id) = (SELECT count(1) FROM course)); 查询至少有一门课与学号为”01”的同学所学相同的同学的信息– 对于这种单个的条件的情况下，使用where in的方式，明显更加直接，如果有多个条件的情况下，使用join才是优势SELECT DISTINCT student.* FROM student INNER JOIN score ON student.s_id = score.s_id WHERE score.c_id IN (SELECT c_id FROM score WHERE s_id = ‘01’) AND student.s_id &lt;&gt; ‘01’; SELECT *FROM studentWHERE s_id &lt;&gt; 01 AND s_id IN (SELECT s_id FROM score WHERE c_id IN (SELECT c_id FROM score WHERE score.s_id = 01) GROUP BY s_id); 查询和”01”号的同学学习的课程完全相同的其他同学的信息– 使用了group_concat的知识，还以为能有什么新鲜的SELECT s.*,tmp1.cids FROM student s INNER JOIN (SELECT s_id,group_concat(c_id ORDER by c_id) as cids FROM score GROUP BY s_id ) tmp1 ON s.s_id = tmp1.s_id AND s.s_id &lt;&gt; ‘01’WHERE tmp1.cids = (SELECT group_concat(c_id ORDER by c_id) as cids FROM score WHERE s_id = ‘01’ GROUP BY s_id ); SELECT student.*, tmp.course_idFROM (SELECT s_id, group_concat(c_id) course_id FROM score GROUP BY s_id HAVING s_id &lt;&gt; 1 AND course_id = (SELECT group_concat(c_id) course_id2 FROM score WHERE s_id = 1))tmp JOIN student ON student.s_id = tmp.s_id; 查询没学过”张三”老师讲授的任一门课程的学生姓名SELECT *FROM studentWHERE s_id NOT IN (SELECT s_id FROM score JOIN (SELECT c_id FROM course WHERE t_id IN (SELECT t_id FROM teacher WHERE t_name = ‘张三’))tmp ON score.c_id = tmp.c_id); –答案2 SELECT student.*FROM student LEFT JOIN (SELECT s_id FROM score JOIN (SELECT c_id FROM course JOIN teacher ON course.t_id = teacher.t_id AND t_name = ‘张三’)tmp2 ON score.c_id = tmp2.c_id)tmp ON student.s_id = tmp.s_idWHERE tmp.s_id IS NULL; 查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩– 关于sum里面可以使用计算条件的方式，很多人都不知道SELECT s.*,round(tmp.avg_score,1) as avg_score FROM student s INNER JOIN (SELECT s_id,avg(s_score) as avg_score FROM score GROUP BY s_id HAVING sum(s_score &lt; 60) &gt;=2) tmp ON s.s_id = tmp.s_id; SELECT student.s_id, student.s_name, tmp.avg_scoreFROM student LEFT JOIN (SELECT s_id, round(AVG(score.s_score)) avg_score FROM score GROUP BY s_id)tmp ON tmp.s_id = student.s_idWHERE student.s_id IN (SELECT s_id FROM score WHERE s_score &lt; 60 GROUP BY score.s_id HAVING count(s_id) &gt; 1); 检索”01”课程分数小于60，按分数降序排列的学生信息SELECT student.*, s_scoreFROM student, scoreWHERE student.s_id = score.s_id AND s_score &lt; 60 AND c_id = ‘01’ORDER BY s_score DESC; 按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩– 在查找的选项里还是可以有这种花式的写法的SELECT s_id, (SELECT s_score FROM score WHERE s_id = a.s_id AND c_id = ‘01’)AS 语文, (SELECT s_score FROM score WHERE s_id = a.s_id AND c_id = ‘02’)AS 数学, (SELECT s_score FROM score WHERE s_id = a.s_id AND c_id = ‘03’)AS 英语, round(avg(s_score), 2) AS 平均分FROM score aGROUP BY s_idORDER BY 平均分 DESC; –答案2– 尝试使用group_concat 的方式处理,外连接的一点模糊领域，要知道一个都连不到的情况下才会出现null SELECT sc.s_id,avg(sc.s_score) as avg_score,group_concat(sc.s_score) FROM score sc RIGHT JOIN course c ON c.c_id = sc.c_idGROUP BY sc.s_id ORDER BY avg_score DESC ; – 由于如果一旦使用了group by sid的方式，那么各科的成绩将无法获取，所以使用left join 多个表的形式处理SELECT a.s_id, tmp1.s_score AS chinese, tmp2.s_score AS math, tmp3.s_score AS english, round(avg(a.s_score), 2) AS avgScoreFROM score a LEFT JOIN (SELECT s_id, s_score FROM score s1 WHERE c_id = ‘01’)tmp1 ON tmp1.s_id = a.s_id LEFT JOIN (SELECT s_id, s_score FROM score s2 WHERE c_id = ‘02’)tmp2 ON tmp2.s_id = a.s_id LEFT JOIN (SELECT s_id, s_score FROM score s3 WHERE c_id = ‘03’)tmp3 ON tmp3.s_id = a.s_idGROUP BY a.s_id, tmp1.s_score, tmp2.s_score, tmp3.s_scoreORDER BY avgScore DESC; 查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率 –及格为&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90– 再次验证了sum里面的条件其实是可以直接等效为case when的，这样就非常方便了SELECT sc.c_id,c.c_name,avg(sc.s_score) avg_score,max(sc.s_score) max_score, min(sc.s_score) min_score,sum(s_score&gt;=60)/count() AS pass_rate, sum(s_score&gt;=80 AND s_score&lt;90)/count() AS good_rateFROM score sc INNER JOIN course c on sc.c_id =c.c_id GROUP BY sc.c_id; SELECT score.c_id AS ‘课程ID’, course.c_name AS ‘课程name’, max(s_score) AS ‘最高分’, min(s_score)AS ‘最低分’, round(avg(s_score), 2) ‘平均分’, round(sum(CASE WHEN s_score &gt;= 60 THEN 1 ELSE 0 END) / sum(CASE WHEN s_score THEN 1 ELSE 0 END), 2)’及格率’, round(sum(CASE WHEN s_score &gt;= 70 AND s_score &lt; 80 THEN 1 ELSE 0 END) / sum(CASE WHEN s_score THEN 1 ELSE 0 END), 2)’中等率’, round(sum(CASE WHEN s_score &gt;= 80 AND s_score &lt; 90 THEN 1 ELSE 0 END) / sum(CASE WHEN s_score THEN 1 ELSE 0 END), 2)’优良率’, round(sum(CASE WHEN s_score &gt;= 90 THEN 1 ELSE 0 END) / (SUM(CASE WHEN s_score THEN 1 ELSE 0 END)), 2)’优秀率’FROM score LEFT JOIN course ON score.c_id = course.c_idGROUP BY score.c_id; –答案2 SELECT course.c_id, course.c_name, tmp.maxScore, tmp.minScore, tmp.avgScore, tmp.passRate, tmp.moderate, tmp.goodRate, tmp.excellentRatesFROM course JOIN (SELECT c_id, max(s_score) AS maxScore, min(s_score)AS minScore, round(avg(s_score), 2) avgScore, round(sum(CASE WHEN s_score &gt;= 60 THEN 1 ELSE 0 END) / count(c_id), 2)passRate, round(sum(CASE WHEN s_score &gt;= 60 AND s_score &lt; 70 THEN 1 ELSE 0 END) / count(c_id), 2) moderate, round(sum(CASE WHEN s_score &gt;= 70 AND s_score &lt; 80 THEN 1 ELSE 0 END) / count(c_id), 2) goodRate, round(sum(CASE WHEN s_score &gt;= 80 AND s_score &lt; 90 THEN 1 ELSE 0 END) / count(c_id), 2) excellentRates FROM score GROUP BY c_id)tmp ON tmp.c_id = course.c_id; 按各科成绩进行排序，并显示排名(实现不完全)– mysql没有rank函数–方法1– 关于排名的sql，很蛋疼的是可能会涉及到不同的同分情况下，是否占用排名的形式– 在select的项里面，可以使用查找语句，查找出的是一个值就是了 (SELECT FROM(SELECT s1.s_id, s1.c_id, s1.s_score,(SELECT COUNT(distinct sc.s_score) FROM score scWHERE sc.s_score&gt;=s1.s_score AND sc.c_id = ‘01’) as ‘rank不保留排名’FROM score s1 WHERE s1.c_id = ‘01’ ORDER BY s1.s_score DESC) t1)UNION (SELECT FROM(SELECT s1.s_id, s1.c_id, s1.s_score,(SELECT COUNT(DISTINCT sc.s_score) FROM score scWHERE sc.s_score&gt;=s1.s_score AND sc.c_id = ‘02’) ‘rank不保留排名’FROM score s1 WHERE s1.c_id = ‘02’ ORDER BY s1.s_score DESC) t2)UNION (SELECT * FROM(SELECT s1.s_id, s1.c_id, s1.s_score,(SELECT COUNT(DISTINCT sc.s_score) FROM score scWHERE sc.s_score&gt;=s1.s_score AND sc.c_id = ‘03’) ‘rank不保留排名’FROM score s1 WHERE s1.c_id = ‘03’ ORDER BY s1.s_score DESC) t3) –方法2 (SELECT a.s_id, a.c_id, @i:=@i+1 AS i保留排名,@k:=(CASE WHEN @score = a.s_score THEN @k ELSE @i END) AS rank不保留排名,@score:=a.s_score AS scoreFROM (SELECT FROM score WHERE c_id = ‘01’ GROUP BY s_id, c_id, s_score ORDER BY s_score DESC)a,(SELECT @i:=0, @k:=0, @score:=0)b)UNION(SELECT a.s_id, a.c_id, @m:=@m+1 AS i保留排名,@k:=(CASE WHEN @score = a.s_score THEN @k ELSE @m END) AS rank不保留排名,@score:=a.s_score AS scoreFROM (SELECT FROM score WHERE c_id = ‘02’ GROUP BY s_id, c_id, s_score ORDER BY s_score DESC)a,(SELECT @m:=0, @k:=0, @score:=0)b)UNION(SELECT a.s_id, a.c_id, @x:=@x+1 AS i保留排名,@k:=(CASE WHEN @score = a.s_score THEN @k ELSE @x END) AS rank不保留排名,@score:=a.s_score AS scoreFROM (SELECT * FROM score WHERE c_id = ‘03’ GROUP BY s_id, c_id, s_score ORDER BY s_score DESC)a,(SELECT @x:=0, @k:=0, @score:=0)b); 查询学生的总成绩并进行排名SELECT score.s_id, s_name, sum(s_score) sumscoreFROM score, studentWHERE score.s_id = student.s_idGROUP BY score.s_idORDER BY sumscore DESC; 查询不同老师所教不同课程平均分从高到低显示–方法1– 自行写法,参考写法实在是多此一举啊SELECT t.t_id,sc.c_id,t.t_name,avg(sc.s_score) avgScoreFROM teacher t INNER JOIN course c ON t.t_id = c.t_id INNER JOIN score sc ON sc.c_id = c.c_idGROUP BY t.t_id,sc.c_id ORDER BY avgScore DESC ; SELECT tmp.c_id, t_id, avgscore AS ‘平均分’FROM ((SELECT DISTINCT c_id, (round((SELECT avg(s_score) FROM score WHERE c_id = ‘01’ GROUP BY c_id), 2))avgscore FROM score s1 WHERE c_id = ‘01’) UNION (SELECT DISTINCT c_id, (round((SELECT avg(s_score) FROM score WHERE c_id = ‘02’ GROUP BY c_id), 2))avgscore FROM score s1 WHERE c_id = ‘02’) UNION (SELECT DISTINCT c_id, (round((SELECT avg(s_score) FROM score WHERE c_id = ‘03’ GROUP BY c_id), 2))avgscore FROM score s1 WHERE c_id = ‘03’))tmp, courseWHERE tmp.c_id = course.c_idORDER BY tmp.avgscore DESC; –方法2 SELECT course.c_id, course.t_id, t_name, round(avg(s_score), 2)AS avgscoreFROM course JOIN teacher ON teacher.t_id = course.t_id JOIN score ON course.c_id = score.c_idGROUP BY score.c_idORDER BY avgscore DESC; –方法3– 使用cross join 的方式反而是对查询效率的降级SELECT course.c_id, course.t_id, t_name, round(avg(s_score), 2)AS avgscoreFROM course, teacher, scoreWHERE teacher.t_id = course.t_id AND course.c_id = score.c_idGROUP BY score.c_idORDER BY avgscore DESC; 查询所有课程的成绩第2名到第3名的学生信息及该课程成绩–方法1– 由于这种情况下，group by 之后没有办法使用limit，而这种特定的名词就是使用Limit的处理合适，所以就使用union进行连接 (SELECT student., tmp1.c_id, tmp1.s_score FROM student,(SELECT s_id, c_id, s_score FROM score WHERE c_id = ‘01’ ORDER BY s_score DESC LIMIT 1, 2)tmp1WHERE student.s_id = tmp1.s_id)UNION (SELECT student., tmp2.c_id, tmp2.s_score FROM student,(SELECT s_id, c_id, s_score FROM score WHERE c_id = ‘02’ ORDER BY s_score DESC LIMIT 1, 2)tmp2WHERE student.s_id = tmp2.s_id)UNION (SELECT student.*, tmp3.c_id, tmp3.s_score FROM student,(SELECT s_id, c_id, s_score FROM score WHERE c_id = ‘03’ ORDER BY s_score DESC LIMIT 1, 2)tmp3WHERE student.s_id = tmp3.s_id); –方法2– 直接找出排名，然后对排名进行筛选，当然是一种方法，但是并不推荐(SELECT student., tmp.c_id, tmp.s_score, tmp.排名 FROM (SELECT a.s_id, a.c_id, a.s_score, @i:=@i+1 AS 排名 FROM score a, (SELECT @i:=0)bWHERE a.c_id = ‘01’ ORDER BY a.s_score DESC)tmp JOIN student ON tmp.s_id = student.s_id WHERE 排名 BETWEEN 2 AND 3)UNION (SELECT student., tmp.c_id, tmp.s_score, tmp.排名 FROM (SELECT a.s_id, a.c_id, a.s_score, @j:=@j+1 AS 排名 FROM score a, (SELECT @j:=0)bWHERE a.c_id = ‘02’ ORDER BY a.s_score DESC)tmp JOIN student ON tmp.s_id = student.s_id WHERE 排名 BETWEEN 2 AND 3) UNION (SELECT student.*, tmp.c_id, tmp.s_score, tmp.排名 FROM (SELECT a.s_id, a.c_id, a.s_score, @k:=@k+1 AS 排名 FROM score a, (SELECT @k:=0)bWHERE a.c_id = ‘03’ ORDER BY a.s_score DESC)tmp JOIN student ON tmp.s_id = student.s_id WHERE 排名 BETWEEN 2 AND 3); 统计各科成绩各分数段人数：课程编号,课程名称,100-85,85-70,70-60,0-60及所占百分比– 很简单可以搞定的东西，为何需要那么复杂啊。。select c.c_id,c.c_name, sum(sc.s_score&lt;=100 AND sc.s_score&gt;=85) AS a, sum(sc.s_score=70) AS b, sum(sc.s_score=60) AS cFROM course c INNER JOIN score sc ON c.c_id = sc.c_idGROUP BY c.c_id ; 查询学生平均成绩及其名次 因为MySQL没有rowcount的函数，所以需要使用此种形式 SELECT a.s_id, a.s_name, a.平均分, @i := @i + 1 AS 排名FROM (SELECT student.s_id, student.s_name, avg(score.s_score) AS “平均分” FROM student, score WHERE student.s_id = score.s_id GROUP BY score.s_id ORDER BY 平均分 DESC)a, (SELECT @i := 0)b; 查询各科成绩前三名的记录– 1.选出b表比a表成绩大的所有组– 2.选出比当前id成绩大的 小于三个的–没有查学生姓名 查找前几名的方法，使用find_in_set真的是可以事半功倍啊！！SELECT s1.*,s2.c_name FROM score s1 INNER JOIN(SELECT sc.c_id,c.c_name,group_concat(sc.s_id ORDER BY sc.s_score DESC) as sids FROM score sc INNER JOIN course c on c.c_id = sc.c_id GROUP BY sc.c_id) s2 ON s1.c_id = s2.c_id WHERE find_in_set(s1.s_id,s2.sids) BETWEEN 1 AND 3 ORDER BY s1.c_id,s1.s_score DESC ; (SELECT score.c_id, course.c_name, s_score FROM score, course WHERE score.c_id = ‘01’ AND course.c_id = score.c_id ORDER BY s_score DESC LIMIT 3)UNION (SELECT score.c_id, course.c_name, s_score FROM score, course WHERE score.c_id = ‘02’ AND course.c_id = score.c_id ORDER BY s_score DESC LIMIT 3)UNION (SELECT score.c_id, course.c_name, s_score FROM score, course WHERE score.c_id = ‘03’ AND course.c_id = score.c_id ORDER BY s_score DESC LIMIT 3); –查了学生姓名 (SELECT score.c_id, course.c_name, student.s_name, s_score FROM scoreJOIN student ON student.s_id = score.s_idJOIN course ON score.c_id = ‘01’ AND course.c_id = score.c_id ORDER BY s_score DESC LIMIT 3)UNION (SELECT score.c_id, course.c_name, student.s_name, s_score FROM scoreJOIN student ON student.s_id = score.s_idJOIN course ON score.c_id = ‘02’ AND course.c_id = score.c_id ORDER BY s_score DESC LIMIT 3 ) UNION (SELECT score.c_id, course.c_name, student.s_name, s_score FROM scoreJOIN student ON student.s_id = score.s_idJOIN course ON score.c_id = ‘03’ AND course.c_id = score.c_id ORDER BY s_score DESC LIMIT 3); 查询每门课程被重修的学生数 能直接连接就不要使用子查询，使用count(1)的形式其实是不严谨的SELECT c.c_id,c.c_name,count(DISTINCT sc.s_id) AS cnt FROM course c LEFT JOIN score sc ON c.c_id = sc.c_idWHERE sc.s_score &lt; 60GROUP BY c.c_id; SELECT c.c_id, c.c_name, a.被选修人数FROM course c JOIN (SELECT c_id, count(1) AS 被选修人数 FROM score WHERE score.s_score &lt; 60 GROUP BY score.c_id)a ON a.c_id = c.c_id; 查询出只有两门课程的全部学生的学号和姓名 还是那句话，如果已经group by了完全的s_id了，那么其他的项都是可以获取到的SELECT s.s_id,s.s_nameFROM student s INNER JOIN score sc ON s.s_id = sc.s_id GROUP BY s.s_id HAVING count(DISTINCT c_id) = 2; SELECT st.s_id, st.s_nameFROM student st JOIN (SELECT s_id FROM score GROUP BY s_id HAVING count(c_id) = 2)a ON st.s_id = a.s_id; 查询男生、女生人数SELECT sum(s_sex = ‘男’) as male, sum(s_sex = ‘女’) as femaleFROM student; SELECT a.男生人数, b.女生人数FROM (SELECT count(1) AS 男生人数 FROM student WHERE s_sex = ‘男’)a, (SELECT count(1) AS 女生人数 FROM student WHERE s_sex = ‘女’)b; 查询名字中含有”风”字的学生信息SELECT *FROM studentWHERE s_name LIKE ‘%风%’; 查询同名同性学生名单，并统计同名人数 统计个数就是聚合的方式，很简单，直接group by就是了，大不了再用find_in_set就是了SELECT s_name,s_sex,GROUP_CONCAT(s_id) sids,count(s_id) cntFROM student GROUP BY s_name,s_sex HAVING count(s_id) &gt;=2; 这是错误的写法，老哥啊SELECT s1.s_name, s1.s_sex, count(*) AS 同名人数FROM student s1, student s2WHERE s1.s_name = s2.s_nameAND s1.s_id &lt;&gt; s2.s_idAND s1.s_sex = s2.s_sexGROUP BY s1.s_name, s1.s_sex; 查询1990年出生的学生名单SELECT *FROM studentWHERE s_birth LIKE ‘1990%’; 查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列SELECT score.c_id, c_name, round(avg(s_score), 2) AS 平均成绩FROM score JOIN course ON score.c_id = course.c_idGROUP BY c_idORDER BY 平均成绩 DESC, score.c_id ASC; 查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩SELECT s.s_id,s.s_name,round(avg(sc.s_score),2) AS avgScoreFROM student s INNER JOIN score sc ON s.s_id = sc.s_idGROUP BY s.s_id HAVING avgScore &gt;= 85; SELECT score.s_id, s_name, round(avg(s_score), 2)AS 平均成绩FROM score JOIN student ON student.s_id = score.s_idGROUP BY score.s_idHAVING 平均成绩 &gt;= 85; 查询课程名称为”数学”，且分数低于60的学生姓名和分数SELECT s_name, s_score AS 数学成绩FROM student JOIN (SELECT s_id, s_score FROM score, course WHERE score.c_id = course.c_id AND c_name = ‘数学’)a ON a.s_score &lt; 60 AND student.s_id = a.s_id; 查询所有学生的课程及分数情况 相当于行列转换的用法了，由于需要就算总分，必须要要使用聚合SELECT a.s_name,SUM(CASE c.c_name WHEN &apos;语文&apos; THEN b.s_score ELSE 0 END) AS 语文, SUM(CASE c.c_name WHEN &apos;数学&apos; THEN b.s_score ELSE 0 END) AS 数学, SUM(CASE c.c_name WHEN &apos;英语&apos; THEN b.s_score ELSE 0 END) AS 英语, SUM(b.s_score) AS 总分 FROM student aJOIN score b ON a.s_id = b.s_id JOIN course c ON b.c_id = c.c_id GROUP BY s_name, a.s_id; 查询任何一门课程成绩在70分以上的学生姓名、课程名称和分数SELECT s.s_id,s.s_name,sc.s_score FROM student s INNER JOIN score sc ON s.s_id = sc.s_idWHERE sc.s_id not IN (SELECT s_id FROM score WHERE s_score &lt; 70 GROUP BY s_id); 又是一个错误的写法SELECT s_name, c_name, s_scoreFROM scoreJOIN student ON student.s_id = score.s_id JOIN course ON score.c_id = course.c_id WHERE s_score &lt; 70; 查询不及格的课程SELECT s_name, c_name AS 不及格课程, tmp.s_scoreFROM student JOIN (SELECT s_id, s_score, c_name FROM score, course WHERE score.c_id = course.c_id AND s_score &lt; 60)tmp ON student.s_id = tmp.s_id; 查询课程编号为01且课程成绩在80分以上的学生的学号和姓名SELECT student.s_id, s_name, s_score AS score_01FROM student JOIN score ON student.s_id = score.s_idWHERE c_id = ‘01’ AND s_score &gt;= 80; 求每门课程的学生人数SELECT course.c_id, course.c_name, count(1)AS 选课人数FROM course JOIN score ON course.c_id = score.c_idGROUP BY score.c_id; 查询选修”张三”老师所授课程的学生中，成绩最高的学生信息及其成绩– 查询老师id 此种查法会丢失调同样都是最高分的学生SELECT s.*,c.c_name,sc.s_scoreFROM student s INNER JOIN score sc ON s.s_id = sc.s_idINNER join course c ON sc.c_id = c.c_id INNER JOIN teacher t ON c.t_id = t.t_id WHERE t.t_name= ‘张三’ ORDER BY sc.s_score DESC LIMIT 1; select s.*,sc.s_score FROM student s inner join score sc ON s.s_id = sc.s_idwhere sc.s_score = ( SELECT max(sc.s_score) FROM score sc INNER join course c ON sc.c_id = c.c_id INNER JOIN teacher t ON c.t_id = t.t_id WHERE t.t_name= ‘张三’ ); – 查询最高分（可能有相同分数） SELECT max(s_score)FROM score JOIN (SELECT course.c_id, c_name FROM course, (SELECT t_id, t_name FROM teacher WHERE t_name = ‘张三’)tmp WHERE course.t_id = tmp.t_id)tmp2 ON score.c_id = tmp2.c_id; 查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩SELECT DISTINCT a.s_id, a.c_id, a.s_scoreFROM score a, score bWHERE a.c_id &lt;&gt; b.c_id AND a.s_score = b.s_score; 查询每门课程成绩最好的前两名–方法1(该方法有bug, 不能查出临界的重复值, 例如查各科的第一名或前三名) 这里如果第一名的话，显然就有问题了SELECT a.s_id, a.c_id, a.s_scoreFROM score aWHERE (SELECT count(1)FROM score b WHERE a.c_id = b.c_id AND b.s_score &gt;= a.s_score) &lt;= 2 ORDER BY a.c_id ASC, a.s_score DESC; –方法2(查前三名) 达成这种效果的话，其实find_in_set的方式更加合理和擅长(SELECT FROM score WHERE c_id = ‘01’ ORDER BY s_score DESC LIMIT 3)UNION (SELECT FROM score WHERE c_id = ‘02’ ORDER BY s_score DESC LIMIT 3)UNION (SELECT * FROM score WHERE c_id = ‘03’ ORDER BY s_score DESC LIMIT 3); -方法三 仍然是使用find_in_set的方式，比起其他的真是好用很多了SELECT sc.* FROM score sc INNER JOIN(SELECT c_id,group_concat(s_id ORDER by s_score DESC) sidsFROM score GROUP BY c_id) tmp ON sc.c_id = tmp.c_id WHEREfind_in_set(sc.s_id,tmp.sids) BETWEEN 1 AND 2 ORDER BY sc.c_id,s_score DESC ;统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列 SELECT DISTINCT course.c_id, tmp.选修人数FROM course JOIN (SELECT c_id, count(1) AS 选修人数 FROM score GROUP BY c_id)tmpWHERE tmp.选修人数 &gt;= 5ORDER BY tmp.选修人数 DESC, course.c_id ASC; 检索至少选修两门课程的学生学号SELECT s_id, count(c_id) AS totalCourseFROM scoreGROUP BY s_idHAVING count(c_id) &gt;= 2; 查询选修了全部课程的学生信息SELECT student.*FROM student, (SELECT s_id, count(c_id) AS totalCourse FROM score GROUP BY s_id)tmpWHERE student.s_id = tmp.s_id AND totalCourse = 3; 查询各学生的年龄– 按照出生日期来算，当前月日 &lt; 出生年月的月日则，年龄减一 date_format之后的可以直接进行加减运算，这个就算是记下了SELECT s_name, s_birth, (DATE_FORMAT(NOW(), ‘%Y’) - DATE_FORMAT(s_birth, ‘%Y’) - CASE WHEN (DATE_FORMAT(NOW(), &apos;%m%d&apos;) &gt; DATE_FORMAT(s_birth, &apos;%m%d&apos;)) THEN 1 ELSE 0 END) AS age FROM student; 查询本周过生日的学生–方法1SELECT *,week(s_birth) FROM studentWHERE week(now()) = week(concat(date_format(now(),’%Y’),date_format(s_birth,’%m%d’))); 以下全错啊！！SELECT *FROM studentWHERE WEEK(DATE_FORMAT(NOW(), ‘%Y%m%d’)) = WEEK(s_birth); 查询本月过生日的学生–方法1 SELECT *,month(s_birth)FROM studentWHERE MONTH(DATE_FORMAT(NOW(), ‘%Y%m%d’)) = MONTH(s_birth);–方法2 这种方法很不正规SELECT s_name, s_sex, s_birthFROM studentWHERE substring(s_birth, 6, 2) = ‘03’;","categories":[{"name":"SQL","slug":"SQL","permalink":"https://www.kikfan.com/categories/SQL/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.kikfan.com/tags/Java/"},{"name":"SQL","slug":"SQL","permalink":"https://www.kikfan.com/tags/SQL/"}]},{"title":"分区助手迁移系统真的是爽","slug":"分区助手迁移系统真的是爽","date":"2019-02-21T17:57:55.000Z","updated":"2019-02-21T17:57:55.000Z","comments":true,"path":"archives/a33f44d0.html","link":"","permalink":"https://www.kikfan.com/archives/a33f44d0.html","excerpt":"","text":"坑爹的建兴SSD，多次无缘无故自动格式化，终于没忍住动手搞搞 在固态中的系统果然是稳的不行","categories":[{"name":"漫漫人生","slug":"漫漫人生","permalink":"https://www.kikfan.com/categories/漫漫人生/"}],"tags":[{"name":"System","slug":"System","permalink":"https://www.kikfan.com/tags/System/"}]},{"title":"Java代码优化","slug":"Java代码优化","date":"2019-02-14T14:51:26.000Z","updated":"2019-02-14T16:58:14.000Z","comments":true,"path":"archives/a2337e7d.html","link":"","permalink":"https://www.kikfan.com/archives/a2337e7d.html","excerpt":"","text":"尽量指定类、方法的final修饰符带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。此举能够使性能平均提高50%。 尽可能使用局部变量调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中，速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。 及时关闭流Java编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。 尽量减少变量的重复计算明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作：12345for(int i;i &lt; list.size();i++) &#123;...&#125;修改为:for(int i,length = list.size;i&lt;length;i++) &#123;...&#125; 这种写法，在list的size很大的时候，可以减少开销 尽量使用懒加载，即在需要的时候创建慎用异常 只在必要使用异常的地方才使用异常，不要用异常去控制程序的流程谨慎地使用异常，异常捕获的代价非常高昂，异常使用过多会严重影响程序的性能。如果在程序中能够用if语句和Boolean变量来进行逻辑判断，那么尽量减少异常的使用，从而避免不必要的异常捕获和处理。比如下面这段经典的程序：1234567891011121314public void useExceptionsForFlowControl() &#123; try &#123; while (true) &#123; increaseCount(); &#125; &#125; catch (MaximumCountReachedException ex) &#123; &#125; //Continue execution &#125; public void increaseCount() throws MaximumCountReachedException &#123; if (count &gt;= 5000) throw new MaximumCountReachedException(); &#125; 上边的useExceptionsForFlowControl()用一个无限循环来增加count直到抛出异常，这种做法并没有说让代码不易读，而是使得程序执行效率降低。 切忌使用空catch块在捕获了异常之后什么都不做，相当于忽略了这个异常。千万不要使用空的catch块，空的catch块意味着你在程序中隐藏了错误和异常，并且很可能导致程序出现不可控的执行结果。如果你非常肯定捕获到的异常不会以任何方式对程序造成影响，最好用Log日志将该异常进行记录，以便日后方便更新和维护。 检查异常和非检查异常的选择一旦你决定抛出异常，你就要决定抛出什么异常。这里面的主要问题就是抛出检查异常还是非检查异常。检查异常导致了太多的try…catch代码，可能有很多检查异常对开发人员来说是无法合理地进行处理的，比如SQLException，而开发人员却不得不去进行try…catch，这样就会导致经常出现这样一种情况：逻辑代码只有很少的几行，而进行异常捕获和处理的代码却有很多行。这样不仅导致逻辑代码阅读起来晦涩难懂，而且降低了程序的性能。我个人建议尽量避免检查异常的使用，如果确实该异常情况的出现很普遍，需要提醒调用者注意处理的话，就使用检查异常；否则使用非检查异常。因此，在一般情况下，我觉得尽量将检查异常转变为非检查异常交给上层处理。 注意catch块的顺序不要把上层类的异常放在最前面的catch块。比如下面这段代码：123456789101112131415try &#123; FileInputStream inputStream = new FileInputStream(\"d:/a.txt\"); int ch = inputStream.read(); System.out.println(\"aaa\"); return \"step1\"; &#125; catch (IOException e) &#123; System.out.println(\"io exception\"); return \"step2\"; &#125;catch (FileNotFoundException e) &#123; System.out.println(\"file not found\"); return \"step3\"; &#125;finally&#123; System.out.println(\"finally block\"); //return \"finally\"; &#125; 第二个catch的FileNotFoundException将永远不会被捕获到，因为FileNotFoundException是IOException的子类。 不要将提供给用户看的信息放在异常信息里比如下面这段代码：123456789101112131415161718public class Main &#123; public static void main(String[] args) &#123; try &#123; String user = null; String pwd = null; login(user,pwd); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; &#125; public static void login(String user,String pwd) &#123; if(user==null||pwd==null) throw new NullPointerException(\"用户名或者密码为空\"); //... &#125;&#125; 展示给用户错误提示信息最好不要跟程序混淆一起，比较好的方式是将所有错误提示信息放在一个配置文件中统一管理。 避免多次在日志信息中记录同一个异常只在异常最开始发生的地方进行日志信息记录。很多情况下异常都是层层向上跑出的，如果在每次向上抛出的时候，都Log到日志系统中，则会导致无从查找异常发生的根源。 异常处理尽量放在高层进行尽量将异常统一抛给上层调用者，由上层调用者统一之时如何进行处理。如果在每个出现异常的地方都直接进行处理，会导致程序异常处理流程混乱，不利于后期维护和异常错误排查。由上层统一进行处理会使得整个程序的流程清晰易懂。 在finally中释放资源如果有使用文件读取、网络操作以及数据库操作等，记得在finally中释放资源。这样不仅会使得程序占用更少的资源，也会避免不必要的由于资源未释放而发生的异常情况。 当复制大量数据时，使用System.arraycopy()命令乘法和除法使用移位操作12345678for(int i = 0;i &lt; 100;i ++)&#123; a = i * 8; b = i / 16;&#125;for(int i -= 0;i &lt; 100; i ++)&#123; a = i &lt;&lt; 3; b = i &gt;&gt; 4;&#125; 移位操作会降低可读性，所以最好带上注释 循环内不要不断创建对象引用尽量在合适的场合使用单例使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面： 控制资源的使用，通过线程同步来控制资源的并发访问 控制实例的产生，以达到节约资源的目的 控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信 ArrayList等实现了RandomAccess接口的集合，应当使用普通for循环而不是foreach循环这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断：123456789if (list instanceof RandomAccess)&#123; for (int i = 0; i &lt; list.size(); i++)&#123;&#125;&#125;else&#123; Iterator&lt;?&gt; iterator = list.iterable(); while (iterator.hasNext())&#123;iterator.next()&#125;&#125; 自己的测试123456789101112131415161718@Testpublic void testRandomAccess()&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 1000000 ; i++) &#123; list.add(i); &#125; Object obj = null; long l = System.currentTimeMillis(); for (int i = 0; i &lt; list.size(); i++) &#123; obj = list.get(i); &#125; long l1 = System.currentTimeMillis(); System.out.println(l1-l); for (Integer x : list) &#123; obj = x; &#125; System.out.println(System.currentTimeMillis() - l1);&#125; 使用同步代码块代替同步方法这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。 程序运行过程避免使用反射关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。 使用带缓冲的输入输出流进行IO操作带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率 公用的集合类中不使用的数据一定要及时remove掉如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。 把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+””最慢1234567891011121314151617181920212223public static void main(String[] args)&#123; int loopTime = 50000; Integer i = 0; long startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++) &#123; String str = String.valueOf(i); &#125; System.out.println(\"String.valueOf()：\" + (System.currentTimeMillis() - startTime) + \"ms\"); startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++) &#123; String str = i.toString(); &#125; System.out.println(\"Integer.toString()：\" + (System.currentTimeMillis() - startTime) + \"ms\"); startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++) &#123; String str = i + \"\"; &#125; System.out.println(\"i + \\\"\\\"：\" + (System.currentTimeMillis() - startTime) + \"ms\");&#125; 结果123String.valueOf()：11msInteger.toString()：5msi + \"\"：25ms 所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString()方法。至于为什么，很简单： String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断 Integer.toString()方法就不说了，直接调用了 i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串三者对比下来，明显是2最快、1次之、3最慢 对资源的close()建议分开操作123456789try&#123; XXX.close(); YYY.close();&#125;catch (Exception e)&#123; ...&#125; 改为12345678910111213141516try&#123; XXX.close();&#125;catch (Exception e)&#123; ...&#125;try&#123; YYY.close();&#125;catch (Exception e)&#123; ...&#125; 虽然有些麻烦，却能避免资源泄露。我们想，如果没有修改过的代码，万一XXX.close()抛异常了，那么就进入了catch块中了，YYY.close()不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为下面的写法之后，就保证了无论如何XXX和YYY都会被close掉 切记以常量定义的方式替代魔鬼数字，魔鬼数字的存在将极大地降低代码可读性，字符串常量是否使用常量定义可以视情况而定推荐使用JDK7中新引入的Objects工具类来进行对象的equals比较，直接a.equals(b)，有空指针异常的风险对于ThreadLocal使用前或者使用后一定要先remove当前基本所有的项目都使用了线程池技术，这非常好，可以动态配置线程数、可以重用线程。然而，如果你在项目中使用到了ThreadLocal，一定要记得使用前或者使用后remove一下。这是因为上面提到了线程池技术做的是一个线程重用，这意味着代码运行过程中，一条线程使用完毕，并不会被销毁而是等待下一次的使用。我们看一下Thread类中，持有ThreadLocal.ThreadLocalMap的引用：123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; 线程不销毁意味着上条线程set的ThreadLocal.ThreadLocalMap中的数据依然存在，那么在下一条线程重用这个Thread的时候，很可能get到的是上条线程set的数据而不是自己想要的内容。这个问题非常隐晦，一旦出现这个原因导致的错误，没有相关经验或者没有扎实的基础非常难发现这个问题，因此在写代码的时候就要注意这一点，这将给你后续减少很多的工作量。 不捕获Java类库中定义的继承自RuntimeException的运行时异常类 ArithmeticException可以通过判断除数是否为空来规避 NullPointerException可以通过判断对象是否为空来规避 IndexOutOfBoundsException可以通过判断数组/字符串长度来规避 ClassCastException可以通过instanceof关键字来规避 ConcurrentModificationException可以使用迭代器来规避 避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降，JDK7之后，可以使用ThreadLocalRandom来获取随机数解释一下竞争同一个seed导致性能下降的原因，比如，看一下Random类的nextInt()方法实现：123public int nextInt() &#123; return next(32);&#125; 调用了next(int bits)方法，这是一个受保护的方法： 复制代码123456789protected int next(int bits) &#123; long oldseed, nextseed; AtomicLong seed = this.seed; do &#123; oldseed = seed.get(); nextseed = (oldseed * multiplier + addend) &amp; mask; &#125; while (!seed.compareAndSet(oldseed, nextseed)); return (int)(nextseed &gt;&gt;&gt; (48 - bits));&#125; 复制代码而这边的seed是一个全局变量：123456/** * The internal state associated with this pseudorandom number generator. * (The specs for the methods in this class describe the ongoing * computation of this value.) */private final AtomicLong seed; 多个线程同时获取随机数的时候，会竞争同一个seed，导致了效率的降低。 转自：五月的仓颉 谨此祭奠过去N多年来逃避现实的自己 永远对这个世界保持好奇心！ 痛苦时分析其产生的根源，去改正能改正的己过，以技术角度为突破口走出来，切莫陷入痛苦的漩涡无法自拔 番茄使人充实，也是驱使你前进的本源！","categories":[{"name":"Java","slug":"Java","permalink":"https://www.kikfan.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.kikfan.com/tags/Java/"},{"name":"代码优化","slug":"代码优化","permalink":"https://www.kikfan.com/tags/代码优化/"}]},{"title":"Java设计模式","slug":"Java设计模式","date":"2019-02-08T16:42:38.000Z","updated":"2019-02-09T06:58:28.000Z","comments":true,"path":"archives/41e00c03.html","link":"","permalink":"https://www.kikfan.com/archives/41e00c03.html","excerpt":"","text":"简单工厂模式 简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。 实体类1234567891011121314151617181920public abstract class Animal &#123; public void shout()&#123; System.out.println(\"动物在叫\"); &#125;&#125;class Dog extends Animal&#123; @Override public void shout() &#123; System.out.println(\"狗在叫\"); &#125;&#125;class Cat extends Animal&#123; @Override public void shout() &#123; System.out.println(\"猫在叫\"); &#125;&#125; 工厂类 12345678910111213141516171819public class AnimalFactory &#123; public static Animal creatAnimal(String name)&#123; Animal animal = null; switch (name) &#123; case \"猫\": animal = new Cat();break; case \"狗\": animal = new Dog();break; default: animal = new Animal() &#123; @Override public void shout() &#123; System.out.println(\"不知名动物在叫\"); &#125; &#125;; &#125; return animal; &#125;&#125; Main函数 12345678910public class Test &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); while (true) &#123; String name = in.next(); Animal animal = AnimalFactory.creatAnimal(name); animal.shout(); &#125; &#125;&#125; 结果 策略模式 它定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。 外观模式 定义：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 外观模式的目的：外观模式的目的不是给子系统添加新的功能接口，而是为了让外部减少与子系统内部多个模块的交互，松散耦合，从而让外部更加简单地使用子系统。 单例模式","categories":[{"name":"Java","slug":"Java","permalink":"https://www.kikfan.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.kikfan.com/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.kikfan.com/tags/设计模式/"}]},{"title":"Netty","slug":"Netty","date":"2019-02-08T16:33:02.000Z","updated":"2019-03-08T08:00:54.000Z","comments":true,"path":"archives/1c6ba3e2.html","link":"","permalink":"https://www.kikfan.com/archives/1c6ba3e2.html","excerpt":"","text":"前进的脚步不停，才是彷徨迷惘的唯一解药 骚年，情商和逆商还是有待提高啊，沦落至此，不就是当初不够不要脸吗，莫在同一个坑跌倒两次！ 让自己忙碌，去获取更高层次的乐趣，形成持久的正反馈机制 Netty依旧闲置，明白自己要的是啥，都是曾经血淋淋的教训，心胸放开阔点，大不了而已。。。 当陷入心烦意乱影响思考的死循环时，最好的办法就是找回场子！各取所需而已 明白那是硬性的矛盾，不要让时间浪费在那种无谓的事情上 最基本的东西，源头的东西不可以动摇 让自己的脑子沉浸在感兴趣的东西里是所向披靡的！！","categories":[{"name":"好奇尚异","slug":"好奇尚异","permalink":"https://www.kikfan.com/categories/好奇尚异/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://www.kikfan.com/tags/Netty/"}]},{"title":"追根溯源，PN结、三极管与场效应管","slug":"追根溯源，PN结与MOS管原理","date":"2019-01-31T09:29:50.000Z","updated":"2019-02-04T03:53:24.000Z","comments":true,"path":"archives/f8b5ed62.html","link":"","permalink":"https://www.kikfan.com/archives/f8b5ed62.html","excerpt":"","text":"热泪盈眶，大学学的东西，终于能起到点桥梁作用了 虽然与编程没有直接的联系，但是却是二进制、寄存器、计算机内存等等的基本原理，源头所在。从源头弄懂，才可以构建一个完整的知识体系，浑身才会舒坦，进而更好地编程。PN结 本征半导体 2019.2.2 更新于k210，别有一番风味 如图为本征半导体的结构，其含义为没有掺杂任何杂质的硅或锗的结构，在热运动下，部分电子会脱离束缚，这样就形成了空穴-电子对，电子是有电荷的，而空穴则具有吸引电子的能力，所以这两者都是属于载流子。 N型材料在本征半导体中掺入磷杂质，那么该种物质的成键方式如图，由于磷的外层具有5个电子，所以则打破了原有的空穴和电子对的平衡，此时电子数远大于空穴数，（注意：宏观上来说，对外界，它仍然是属于电中性的），由于其结构体中，电子很多，故称该种掺磷的本征半导体为N（Negative）材料。（导电的本质是载流子的运动，形成电流而已，当一种物质具有很多载流子时，则其导电能力就增强）。 P型材料和掺磷的相对应，由于硼的外层电子数为3，所以形成共价键时，空穴更多，空穴是吸引电子，所以该种物质属于P(Positive)材料 将P型材料和N型材料相连构成PN结将两者相连之后，由于空穴和电子的相互吸引，则PN结则会相互发生扩散运动，此时注意了，由于这两种材料，连接之前其实都还是呈现电中性的，所以，P型材料失去空穴（吸引了电子），带负电。N型半导体失去了电子，则带正电。因此则形成了内电场，该内电场是阻碍扩散运动的，会使空穴和电子与扩散运动相反的方向运动，称为漂移运动。那么，这样会最终形成一个稳定状态，即局部区域内，扩散运动和漂移运动相平衡，这个区域被称为耗尽层，由于该内部空穴和电子相平衡，所以相当于其载流子很少，即阻碍导电。 那么将PN结两端用导线连接起来，并加以电源，此时电压方向有两种，如图显示的为P点电势更高，此时外电场与内电场方向相反，会削弱内电场，即导电性能会增强。反之则导电性能变差（在高压下，耗尽层非常宽，电阻很大，可视为无法导电）。这样，PN结实际上就实现了一种单向导电的功能。 三极管三极管的一个重要作用就是用小电流1控制大电流，该种情况工作在三极管的放大区，此时发射结正偏，而集电结反偏，通过控制Ibe的电流，控制ce的电流。类似于小水龙头控制大水龙头的过程。 场效应管从结构划分 结型场效应管可将N沟道JFET看作带“人工智能开关”的水龙头。这就有三部分：进水、人工智能开关、出水，可以分别看成是JFET的 d极 、g 极、s极。“人工”体现了开关的“控制”作用即vGS。JFET工作时，在栅极与源极之间需加一负电压(vGS&lt;0)，使栅极、沟道间的PN结反偏，栅极电流iG≈0，场效应管呈现高达107Ω以上的输入电阻。在漏极与源极之间加一正电压(vDS&gt;0)，使N沟道中的多数载流子(电子)在电场作用下由源极向漏极运动，形成电流iD。iD的大小受“人工开关”vGS的控制，vGS由零往负向增大时，PN结的耗尽层将加宽，导电沟道变窄，vGS绝对值越大则人工开关越接近于关上，流出的水(iD)肯定越来越小了，当你把开关关到一定程度的时候水就不流了。“智能”体现了开关的“影响”作用，当水龙头两端压力差(vDS)越大时，则人工开关自动智能“生长”。vDS值越大则人工开关生长越快，流水沟道越接近于关上，流出的水(iD)肯定越小了，当人工开关生长到一定程度的时候水也就不流了。理论上，随着vDS逐渐增加，一方面沟道电场强度加大，有利于漏极电流iD增加;另一方面，有了vDS，就在由源极经沟道到漏极组成的N型半导体区域中，产生了一个沿沟道的电位梯度。由于N沟道的电位从源端到漏端是逐渐升高的，所以在从源端到漏端的不同位置上，漏极与沟道之间的电位差是不相等的，离源极越远，电位差越大，加到该处PN结的反向电压也越大，耗尽层也越向N型半导体中心扩展，使靠近漏极处的导电沟道比靠近源极要窄，导电沟道呈楔形。所以形象地比喻为当水龙头两端压力差(vDS)越大，则人工开关自动智能“生长”。当开关第一次相碰时，就是预夹断状态，预夹断之后id趋于饱和。当vGS&gt;0时，将使PN结处于正向偏置而产生较大的栅流，破坏了它对漏极电流iD的控制作用，即将人工开关拔出来，在开关处又加了一根进水水管，对水龙头就没有控制作用了。 绝缘栅型场效应管可将N沟道MOSFET看作带“人工智能开关”的水龙头。相对应情况同JFET。与JFET不同的的是，MOSFET刚开始人工开关是关着的，水流流不出来。当在栅源之间加vGS&gt;0， N型感生沟道(反型层)产生后，人工开关逐渐打开，水流(iD)也就越来越大。iD的大小受“人工开关”vGS的控制，vGS由零往正向增大时，则栅极和P型硅片相当于以二氧化硅为介质的平板电容器，在正的栅源电压作用下，介质中便产生了一个垂直于半导体表面的由栅极指向P型衬底的电场，这个电场排斥空穴而吸引电子，P型衬底中的少子电子被吸引到衬底表面，这些电子在栅极附近的P型硅表面便形成了一个N型薄层，即导通源极和漏极间的N型导电沟道。栅源电压vGS越大则半导体表面的电场就越强，吸引到P型硅表面的电子就越多，感生沟道将越厚，沟道电阻将越小。相当于人工开关越接近于打开，流出的水(iD)肯定越来越多了，当你把开关开到一定程度的时候水流就达到最大了。MOSFET的“智能”性与JFET原理相同，参上。","categories":[{"name":"好奇尚异","slug":"好奇尚异","permalink":"https://www.kikfan.com/categories/好奇尚异/"}],"tags":[{"name":"PN结","slug":"PN结","permalink":"https://www.kikfan.com/tags/PN结/"},{"name":"三极管","slug":"三极管","permalink":"https://www.kikfan.com/tags/三极管/"},{"name":"场效应管","slug":"场效应管","permalink":"https://www.kikfan.com/tags/场效应管/"}]},{"title":"Java高质量问题","slug":"Java高质量问题","date":"2019-01-28T16:35:16.000Z","updated":"2019-02-12T10:23:28.000Z","comments":true,"path":"archives/12d199bb.html","link":"","permalink":"https://www.kikfan.com/archives/12d199bb.html","excerpt":"","text":"千万不能沉溺于回报周期短的、微小的正反馈不能自拔，而要找到让你一路走下去的真正动力。得失心不要太重，目光不要太短，人生百年，说短也短，说长，其实也挺长的。题目1、MySQL中 like%%和find_in_set的区别find_in_set对于查找以英文逗号分隔的字段，更加具有精确性 题目2、Java类初始化顺序基类静态代码块，基类静态成员字段（并列优先级，按照代码中出现的先后顺序执行，且只有第一次加载时执行）——&gt;派生类静态代码块，派生类静态成员字段（并列优先级，按照代码中出现的先后顺序执行，且只有第一次加载时执行）——&gt;基类普通代码块，基类普通成员字段（并列优点级，按代码中出现先后顺序执行）——&gt;基类构造函数——&gt;派生类普通代码块，派生类普通成员字段（并列优点级，按代码中出现先后顺序执行）——&gt;派生类构造函数 题目3、一个java文件有3个类，编译后有几个class文件文件中有几个类编译后就有几个class文件。 题目4、局部变量为何必须要显式地赋值才可以使用成员变量是可以不经初始化的，在类加载过程的准备阶段即可给它赋予默认值，但局部变量使用前需要显式赋予初始值，javac不是推断不出不可以这样做，而是没有这样做，对于成员变量而言，其赋值和取值访问的先后顺序具有不确定性，对于成员变量可以在一个方法调用前赋值，也可以在方法调用后进行，这是运行时发生的，编译器确定不了，交给jvm去做比较合适。而对于局部变量而言，其赋值和取值访问顺序是确定的。 题目5、写一个死锁 死锁概念及产生原理 概念：多个并发进程因争夺系统资源而产生相互等待的现象。 原理：当一组进程中的每个进程都在等待某个事件发生，而只有这组进程中的其他进程才能触发该事件，这就称这组进程发生了死锁。 本质原因： 1）、系统资源有限。 2）、进程推进顺序不合理。死锁产生的4个必要条件 1、互斥：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。 2、占有且等待：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。 3、不可抢占：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。 4、循环等待：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。当以上四个条件均满足，必然会造成死锁，发生死锁的进程无法进行下去，它们所持有的资源也无法释放。这样会导致CPU的吞吐量下降。所以死锁情况是会浪费系统资源和影响计算机的使用性能的。那么，解决死锁问题就是相当有必要的了。思想为：定义两个ArrayList,将他们都加上锁A,B，线程1,2，1拿住了锁A ，请求锁B，2拿住了锁B请求锁A，在等待对方释放锁的过程中谁也不让出已获得的锁。12345678910111213141516171819202122232425262728293031323334353637383940public class DeadLock &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list1 = Arrays.asList(1, 2, 3); List&lt;Integer&gt; list2 = Arrays.asList(4, 5, 6); new Thread(()-&gt; &#123; synchronized (list1)&#123; for (Integer o : list1) &#123; System.out.println(o); &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (list2) &#123; for (Integer o : list2) &#123; System.out.println(o); &#125; &#125; &#125; &#125;).start(); new Thread(()-&gt; &#123; synchronized (list2)&#123; for (Integer o : list2) &#123; System.out.println(o); &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (list1) &#123; for (Integer o : list1) &#123; System.out.println(o); &#125; &#125; &#125; &#125;).start(); &#125;&#125;","categories":[{"name":"好奇尚异","slug":"好奇尚异","permalink":"https://www.kikfan.com/categories/好奇尚异/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.kikfan.com/tags/Java/"},{"name":"题目","slug":"题目","permalink":"https://www.kikfan.com/tags/题目/"}]},{"title":"有意思的Java单例模式","slug":"有意思的Java单例模式","date":"2019-01-25T09:26:18.000Z","updated":"2019-01-25T14:19:46.000Z","comments":true,"path":"archives/e95c6f09.html","link":"","permalink":"https://www.kikfan.com/archives/e95c6f09.html","excerpt":"","text":"前言Java的单例模式号称最简单的设计模式，然后其实并没有那么简单，下面来研究研究单例模式的具体实现 饿汉式1234567891011public class SingletonB &#123; private static final SingletonB INSTANCE = new SingletonB(); private SingletonB() &#123; &#125; public static SingletonB getInstance()&#123; return INSTANCE; &#125;&#125; 如上所示为饿汉式的单例模式的实现，全局的单例实例在类加载的时候就构建（可以免疫很多多线程的问题），但是该种方式也缺陷明显，浪费资源。 v1.懒汉式 1234567891011121314public class SingletonA1 &#123; private static SingletonA1 INSTANCE; private SingletonA1() &#123; &#125; public static SingletonA1 getInstance()&#123; if (INSTANCE == null) &#123; INSTANCE = new SingletonA1(); &#125; return INSTANCE; &#125;&#125; 如上为简单版懒汉模式，相比饿汉式，在需要的时候才构建实例，然而多线程的场景下，如果有多个线程同时判断了INSTANCE为null，则系统中会出现多个实例 v2.synchronized版本1234567891011121314public class SingletonA2 &#123; private static SingletonA2 INSTANCE; private SingletonA2() &#123; &#125; public static synchronized SingletonA2 getInstance()&#123; if (INSTANCE == null) &#123; INSTANCE = new SingletonA2(); &#125; return INSTANCE; &#125;&#125; 既然如此，将获取实例的方法加锁即可，确实可以避免v1版的问题，但是一旦方法加锁之后同步了，所有其他线程都被阻塞，为了1%可能导致的多线程问题，而造成了效率上的大大降低，其实是得不偿失的 v3.Double-Check版本123456789101112131415161718public class SingletonA3 &#123; private static SingletonA3 INSTANCE; private SingletonA3() &#123; &#125; public static SingletonA3 getInstance() &#123; if (INSTANCE == null) &#123; synchronized (SingletonA3.class) &#123; if (INSTANCE == null) &#123; INSTANCE = new SingletonA3(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; 双检法，当实例为null的时候，才加锁，相对于v2版本，只针对那1%的时候，进行同步处理到了这里，基本就是完美的了，然而事情并没有这么简单！！！INSTANCE = new SingletonA3();该语句并非是原子性的（不可分割）细分之后为1.INSTANCE分配内存2.SingletonA3调用构造器在堆中构建实例3.将INSTANCE指向堆中的实例而Java有指令重排的机制，并非一定是123的顺序，如果是132的顺序时，刚执行完13，此时恰好，有另外的线程在进行第一个if (INSTANCE == null)的判断，此时判断INSTANCE是非null的，则会直接返回，然而实际上它并没有正确指向堆，所以理所应该地就报错了。如下则为指令重排详解 指令重排简单来说，就是计算机为了提高执行效率，会做的一些优化，在不影响最终结果的情况下，可能会对一些语句的执行顺序进行调整。比如，这一段代码：1234567int a ; // 语句1 a = 8 ; // 语句2int b = 9 ; // 语句3int c = a + b ; // 语句4 正常来说，对于顺序结构，执行的顺序是自上到下，也即1234。但是，由于指令重排的原因，因为不影响最终的结果，所以，实际执行的顺序可能会变成3124或者1324。由于语句3和4没有原子性的问题，语句3和语句4也可能会拆分成原子操作，再重排。——也就是说，对于非原子性的操作，在不影响最终结果的情况下，其拆分成的原子操作可能会被重新排列执行顺序。OK，了解了原子操作和指令重排的概念之后，我们再继续看Version3代码的问题。下面这段话直接从陈皓的文章(深入浅出单实例SINGLETON设计模式)中复制而来：主要在于singleton = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。 给 singleton 分配内存 调用 Singleton 的构造函数来初始化成员变量，形成实例 将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null 了）但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。再稍微解释一下，就是说，由于有一个『instance已经不为null但是仍没有完成初始化』的中间状态，而这个时候，如果有其他线程刚好运行到第一层if (instance == null)这里，这里读取到的instance已经不为null了，所以就直接把这个中间状态的instance拿去用了，就会产生问题。这里的关键在于——线程T1对instance的写操作没有完成，线程T2就执行了读操作。 v4.volatile关键字完美版123456789101112131415161718public class SingletonA4 &#123; private static volatile SingletonA4 INSTANCE; private SingletonA4() &#123; &#125; public static SingletonA4 getInstance() &#123; if (INSTANCE == null) &#123; synchronized (SingletonA4.class) &#123; if (INSTANCE == null) &#123; INSTANCE = new SingletonA4(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; volatile关键字的作用在于，在写之前即INSTANCE = new SingletonA4();操作之前，不会进行读操作，即if (INSTANCE == null)操作这是双检法的终极版本，要说缺点的话，就是写法太复杂了 静态内部类法1234567891011121314public class SingletonC &#123; private SingletonC() &#123; &#125; static class SingetonHolder &#123; private static SingetonHolder INSTANCE = new SingetonHolder(); public static SingetonHolder getInstance() &#123; return INSTANCE; &#125; &#125;&#125; 内部类的方法，该种方式，获取实例的方式是饿汉式的，然后由于它属于内部类，并不会在外层SingletonC类加载的时候进行构建所以是非常巧妙的实现 枚举法下面是使用enum的实现方式123456789101112131415public enum SingletonD &#123; INSTANCE; public void dosth()&#123; System.out.println(\"枚举法的实现方式\"); &#125;&#125;public class SingletonTest &#123; @Test public void testSingleton()&#123; SingletonD.INSTANCE.dosth(); &#125;&#125; 枚举法简洁直观，要说缺点的话，因为它不是class所以无法继承","categories":[{"name":"好奇尚异","slug":"好奇尚异","permalink":"https://www.kikfan.com/categories/好奇尚异/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.kikfan.com/tags/Java/"},{"name":"单例模式","slug":"单例模式","permalink":"https://www.kikfan.com/tags/单例模式/"}]},{"title":"bitmap,有点意思","slug":"bitmap-有点意思","date":"2019-01-20T05:17:00.000Z","updated":"2019-01-20T05:17:00.000Z","comments":true,"path":"archives/78236c9b.html","link":"","permalink":"https://www.kikfan.com/archives/78236c9b.html","excerpt":"","text":"位移操作的基本概念与逻辑运算123456a = 0010(0x02)a &gt;&gt;= 1; (a 右移1位并把右移的结果重新赋值给a) 此时a = 0001(0x01);a &lt;&lt;= 1；（a左移1位并把左移的结果重新赋值给a） 此时 a = 0100(0x04);a &amp;= 0x01;（ a与0x01 按位与，并把按位与的结果重新赋值给a）。此时a = 0x0;a |= 0x01;（ a与0x01 按位或，并把按位或的结果重新赋值给a）。此时a = 0011(0x03);a ^= 0x01;（ a与0x01 按位异或，并把按位异或的结果重新赋值给a）。此时a = 0x03;(异或的意思就是，该位均为相同的则该位结果为0，该位均为不同的则该位结果为1) 12345678@Testpublic void testBit()&#123; int a = 8; // 二进制里的加减法 System.out.println(~a == -9); System.out.println(-~a == a + 1); System.out.println(~-a == a - 1);&#125; 扩展的bitmap,最高统计次数为15次1234567891011121314151617181920212223242526package com.gustave.practice.hobby.interest;public class BitMap &#123; public static final int PER_WORDS = 5; public int[] words; // 每个数字最高出现16次，既需要4bit来表示 public static final int FINAL_PER_WORDS = 3; public BitMap(int size) &#123; words = new int[((size - 1) &gt;&gt; FINAL_PER_WORDS) + 1]; &#125; public void set(int wordIndex) &#123; int num = this.get(wordIndex); if (num &lt; 15) &#123; int count = (wordIndex - 1) % (1 &lt;&lt; FINAL_PER_WORDS); words[wordIndex &gt;&gt; FINAL_PER_WORDS] += (1 &lt;&lt; count * 4); &#125; &#125; public int get(int wordIndex) &#123; int count = (wordIndex - 1) % (1 &lt;&lt; FINAL_PER_WORDS); int num = (words[wordIndex &gt;&gt; FINAL_PER_WORDS] &amp; (15 &lt;&lt; count * 4)) / (1 &lt;&lt; count * 4); return num &lt; 0 ? 16 + num : num; &#125;&#125; 测试的类1234567891011121314151617181920212223242526272829303132package com.gustave.practice.testWork.bitMap;import com.gustave.practice.hobby.interest.BitMap;import org.junit.Test;public class MyBitMap &#123; @Test public void test()&#123; int size = 100; BitMap bitMap = new BitMap(size); for (int i = 1; i &lt;100 ; i++) &#123; bitMap.set(i); &#125; bitMap.set(1); bitMap.set(1); bitMap.set(2); for (int i = 0; i &lt;9 ; i++) &#123; bitMap.set(8); &#125; for (int i = 0; i &lt;19 ; i++) &#123; bitMap.set(16); bitMap.set(17); &#125; System.out.println(bitMap.get(1)); System.out.println(bitMap.get(2)); System.out.println(bitMap.get(12)); System.out.println(bitMap.get(8)); System.out.println(bitMap.get(16)); System.out.println(bitMap.get(17)); &#125;&#125; 结果123456321101515","categories":[{"name":"好奇尚异","slug":"好奇尚异","permalink":"https://www.kikfan.com/categories/好奇尚异/"}],"tags":[{"name":"bitmap","slug":"bitmap","permalink":"https://www.kikfan.com/tags/bitmap/"}]},{"title":"TCP/IP网络","slug":"TCP-IP网络","date":"2019-01-14T03:53:10.000Z","updated":"2019-01-14T03:53:10.000Z","comments":true,"path":"archives/4e962cde.html","link":"","permalink":"https://www.kikfan.com/archives/4e962cde.html","excerpt":"","text":"网络地址 在网络层和传输层，寻址是通过IP地址和MAC地址，但是IP地址具有层次性，而MAC地址虽为最终通信地址，但不具有层次 IP地址和MAC地址是相互配合的关系，把IP地址通过ARP缓存获取具体的MAC地址，最终发送的消息到达的是MAC地址 关于子网掩码 子网掩码与IP地址都是由4个数段组成，每个数段的取值范围是0-255（共256个值，等于2的8次方），如我们在搭建局域网时通常用到的IP地址192.168.1.1，子网掩码255.255.255.0，当然十进制是为了方便人的理解，转换成机器能识别的二进制后，每个数段由8个0或1组成，一个完整的IP地址或子网掩码就转换成32个0或1组成的序列。子网掩码与IP地址是组合使用的，IP地址我们都知道是计算机在网络内的唯一标识，而子网掩码顾名思义是用于划分子网的. Keep Moving Anyway","categories":[{"name":"好奇尚异","slug":"好奇尚异","permalink":"https://www.kikfan.com/categories/好奇尚异/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"https://www.kikfan.com/tags/网络基础/"},{"name":"TCP","slug":"TCP","permalink":"https://www.kikfan.com/tags/TCP/"},{"name":"IP","slug":"IP","permalink":"https://www.kikfan.com/tags/IP/"}]},{"title":"Redis,Sentinel高可用","slug":"Redis-Sentinel高可用","date":"2019-01-10T19:22:29.000Z","updated":"2019-01-10T19:38:37.000Z","comments":true,"path":"archives/b6f06c4a.html","link":"","permalink":"https://www.kikfan.com/archives/b6f06c4a.html","excerpt":"","text":"redis,sentinel的高可用,必须允许sentinel更改配置文件 查找资料，分析原因，问题在于使用了Docker之后，不在同一网段 解决办法，使用host网络模式即可 借此，引申需要研究Docker-Compose的各项命令，网络模式的研究 redis.yml配置12345678910111213141516171819202122232425262728293031323334353637version: '3.1'services: redis1: image: redis:3.2.1 container_name: redis1 restart: always command: /usr/local/bin/redis-server /usr/local/redis.conf volumes: - /usr/local/docker/redis/redis1-data:/data - /usr/local/docker/redis/redis1.conf:/usr/local/redis.conf ports: - 6379:6379 network_mode: \"host\" redis2: image: redis:3.2.1 container_name: redis2 restart: always command: /usr/local/bin/redis-server /usr/local/redis.conf volumes: - /usr/local/docker/redis/redis2-data:/data - /usr/local/docker/redis/redis2.conf:/usr/local/redis.conf ports: - 6380:6379 network_mode: \"host\" redis3: image: redis:3.2.1 container_name: redis3 restart: always command: /usr/local/bin/redis-server /usr/local/redis.conf volumes: - /usr/local/docker/redis/redis3-data:/data - /usr/local/docker/redis/redis3.conf:/usr/local/redis.conf ports: - 6381:6381 network_mode: \"host\" redis.conf master 123port 6379masterauth 123456requirepass 123456 slave 1234port 6380masterauth 123456requirepass 123456slaveof 192.168.213.129 6379 sentinel.yml12345678910111213141516171819202122232425262728293031323334version: '3.1'services: sentinel1: image: redis:3.2.1 container_name: redis-sentinel-1 ports: - 26379:26379 command: redis-sentinel /usr/local/etc/redis/sentinel.conf volumes: - /usr/local/docker/redis/sentinel1.conf:/usr/local/etc/redis/sentinel.conf - /usr/local/docker/redis/sentinel1-data:/data network_mode: \"host\" sentinel2: image: redis:3.2.1 container_name: redis-sentinel-2 ports: - 26380:26379 command: redis-sentinel /usr/local/etc/redis/sentinel.conf volumes: - /usr/local/docker/redis/sentinel2.conf:/usr/local/etc/redis/sentinel.conf - /usr/local/docker/redis/sentinel2-data:/data network_mode: \"host\" sentinel3: image: redis:3.2.1 container_name: redis-sentinel-3 ports: - 26381:26379 command: redis-sentinel /usr/local/etc/redis/sentinel.conf volumes: - /usr/local/docker/redis/sentinel3.conf:/usr/local/etc/redis/sentinel.conf - /usr/local/docker/redis/sentinel3-data:/data network_mode: \"host\" sentinel.conf1234567port 26379sentinel monitor mymaster 192.168.213.129 6379 2sentinel auth-pass mymaster 123456sentinel down-after-milliseconds mymaster 15000sentinel parallel-syncs mymaster 1sentinel failover-timeout mymaster 80000protected-mode no","categories":[{"name":"好奇尚异","slug":"好奇尚异","permalink":"https://www.kikfan.com/categories/好奇尚异/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.kikfan.com/tags/Redis/"},{"name":"Sentinel","slug":"Sentinel","permalink":"https://www.kikfan.com/tags/Sentinel/"},{"name":"Docker","slug":"Docker","permalink":"https://www.kikfan.com/tags/Docker/"}]},{"title":"Kubernates(k8s)","slug":"Kubernates-k8s","date":"2019-01-06T17:54:23.000Z","updated":"2019-01-06T17:54:23.000Z","comments":true,"path":"archives/5c5aaca6.html","link":"","permalink":"https://www.kikfan.com/archives/5c5aaca6.html","excerpt":"","text":"搭建k8s集群主机名映射1234cat /etc/hosts127.0.0.1 localhost192.168.213.130 k8s-master192.168.213.131 k8s-slave 主机名和IP加入到hostname1cat /etc/hostname 在所有节点上安装kubeadm，这里使用阿里云的系统和kubernetes的源1234567root@k8s-master:~# cat /etc/apt/sources.listdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main 更新源并安装kubeadm, kubectl, kubelet软件包;安装docker.io(非docker-ce)123apt-get update -y &amp;&amp; apt-get install -y kubelet kubeadm kubectl --allow-unauthenticatedapt-get install docker.io -y 使用kubeadmin初始化master节点，这里有两个坑！！ 坑1、使用网络上常见的方式，那么如果没有用vpn翻墙，那么则会卡住，无法下载，幸好v1.13.0版本无需翻墙，指定版本即可 12345kubeadm init \\--image-repository registry.aliyuncs.com/google_containers \\--kubernetes-version v1.13.0 \\--pod-network-cidr=10.244.0.0/16 \\--apiserver-advertise-address=192.168.213.130 坑2、需要禁用swap修改/etc/fstab 123456789101112root@k8s-master:~# cat /etc/fstab # /etc/fstab: static file system information.## Use &apos;blkid&apos; to print the universally unique identifier for a# device; this may be used with UUID= as a more robust way to name devices# that works even if disks are added and removed. See fstab(5).## &lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;/dev/mapper/ubuntugustave--vg-root / ext4 errors=remount-ro 0 1# /boot was on /dev/sda1 during installation# UUID=340c3d0f-eb29-4512-83ca-ef6ba9d8577f /boot ext2 defaults 0 2# /dev/mapper/ubuntugustave--vg-swap_1 none swap sw 0 0 修改之后执行swapoff -a如果还不行 kubeadm reset 大功告成12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667root@k8s-master:~# kubeadm init --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.13.0 --pod-network-cidr=10.244.0.0/16 --apiserver-advertise-address=192.168.213.130[init] Using Kubernetes version: v1.13.0[preflight] Running pre-flight checks[preflight] Pulling images required for setting up a Kubernetes cluster[preflight] This might take a minute or two, depending on the speed of your internet connection[preflight] You can also perform this action in beforehand using &apos;kubeadm config images pull&apos;[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;[kubelet-start] Activating the kubelet service[certs] Using certificateDir folder &quot;/etc/kubernetes/pki&quot;[certs] Generating &quot;etcd/ca&quot; certificate and key[certs] Generating &quot;etcd/healthcheck-client&quot; certificate and key[certs] Generating &quot;etcd/server&quot; certificate and key[certs] etcd/server serving cert is signed for DNS names [k8s-master localhost] and IPs [192.168.213.130 127.0.0.1 ::1][certs] Generating &quot;etcd/peer&quot; certificate and key[certs] etcd/peer serving cert is signed for DNS names [k8s-master localhost] and IPs [192.168.213.130 127.0.0.1 ::1][certs] Generating &quot;apiserver-etcd-client&quot; certificate and key[certs] Generating &quot;ca&quot; certificate and key[certs] Generating &quot;apiserver-kubelet-client&quot; certificate and key[certs] Generating &quot;apiserver&quot; certificate and key[certs] apiserver serving cert is signed for DNS names [k8s-master kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 192.168.213.130][certs] Generating &quot;front-proxy-ca&quot; certificate and key[certs] Generating &quot;front-proxy-client&quot; certificate and key[certs] Generating &quot;sa&quot; key and public key[kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot;[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file[control-plane] Using manifest folder &quot;/etc/kubernetes/manifests&quot;[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;[etcd] Creating static Pod manifest for local etcd in &quot;/etc/kubernetes/manifests&quot;[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;/etc/kubernetes/manifests&quot;. This can take up to 4m0s[apiclient] All control plane components are healthy after 28.005554 seconds[uploadconfig] storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace[kubelet] Creating a ConfigMap &quot;kubelet-config-1.13&quot; in namespace kube-system with the configuration for the kubelets in the cluster[patchnode] Uploading the CRI Socket information &quot;/var/run/dockershim.sock&quot; to the Node API object &quot;k8s-master&quot; as an annotation[mark-control-plane] Marking the node k8s-master as control-plane by adding the label &quot;node-role.kubernetes.io/master=&apos;&apos;&quot;[mark-control-plane] Marking the node k8s-master as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule][bootstrap-token] Using token: 3lnb74.tku3cdu5bagn0air[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles[bootstraptoken] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials[bootstraptoken] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token[bootstraptoken] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster[bootstraptoken] creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace[addons] Applied essential addon: CoreDNS[addons] Applied essential addon: kube-proxyYour Kubernetes master has initialized successfully!To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/You can now join any number of machines by running the following on each nodeas root: kubeadm join 192.168.213.130:6443 --token 3lnb74.tku3cdu5bagn0air --discovery-token-ca-cert-hash sha256:2ba48ce20ebefcfb6d07ddf01141590eb81cad5de5c0406f08f41faab26a8696 按图索骥,按指示的方式配置k8s就行了,其中最后显示的kubeadm join语句包含了节点添加的token等等123mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config 安装网络插件canal 执行如下两条命令即可12345678910111213141516171819kubectl apply -f https://docs.projectcalico.org/v3.1/getting-started/kubernetes/installation/hosted/canal/rbac.yaml clusterrole.rbac.authorization.k8s.io &quot;calico&quot; createdclusterrole.rbac.authorization.k8s.io &quot;flannel&quot; createdclusterrolebinding.rbac.authorization.k8s.io &quot;canal-flannel&quot; createdclusterrolebinding.rbac.authorization.k8s.io &quot;canal-calico&quot; created kubectl apply -f https://docs.projectcalico.org/v3.1/getting-started/kubernetes/installation/hosted/canal/canal.yaml configmap &quot;canal-config&quot; createddaemonset.extensions &quot;canal&quot; createdcustomresourcedefinition.apiextensions.k8s.io &quot;felixconfigurations.crd.projectcalico.org&quot; createdcustomresourcedefinition.apiextensions.k8s.io &quot;bgpconfigurations.crd.projectcalico.org&quot; createdcustomresourcedefinition.apiextensions.k8s.io &quot;ippools.crd.projectcalico.org&quot; createdcustomresourcedefinition.apiextensions.k8s.io &quot;clusterinformations.crd.projectcalico.org&quot; createdcustomresourcedefinition.apiextensions.k8s.io &quot;globalnetworkpolicies.crd.projectcalico.org&quot; createdcustomresourcedefinition.apiextensions.k8s.io &quot;networkpolicies.crd.projectcalico.org&quot; createdserviceaccount &quot;canal&quot; created 执行如下命令，可以就可以查看canal的安装状态了123456789101112root@k8s-master:~# kubectl get pod -n kube-system -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATEScanal-6f6kk 3/3 Running 0 58m 192.168.213.130 k8s-master &lt;none&gt; &lt;none&gt;canal-rgb57 3/3 Running 0 50m 192.168.213.131 k8s-slave &lt;none&gt; &lt;none&gt;coredns-78d4cf999f-hp7cv 1/1 Running 0 64m 10.244.0.3 k8s-master &lt;none&gt; &lt;none&gt;coredns-78d4cf999f-p4r7w 1/1 Running 0 64m 10.244.0.2 k8s-master &lt;none&gt; &lt;none&gt;etcd-k8s-master 1/1 Running 0 69m 192.168.213.130 k8s-master &lt;none&gt; &lt;none&gt;kube-apiserver-k8s-master 1/1 Running 0 68m 192.168.213.130 k8s-master &lt;none&gt; &lt;none&gt;kube-controller-manager-k8s-master 1/1 Running 0 69m 192.168.213.130 k8s-master &lt;none&gt; &lt;none&gt;kube-proxy-fknxh 1/1 Running 0 50m 192.168.213.131 k8s-slave &lt;none&gt; &lt;none&gt;kube-proxy-pvt8w 1/1 Running 0 69m 192.168.213.130 k8s-master &lt;none&gt; &lt;none&gt;kube-scheduler-k8s-master 1/1 Running 0 69m 192.168.213.130 k8s-master &lt;none&gt; &lt;none&gt; 查看节点1kubectl get nodes slave节点在集群中的操作增加新的Node节点到你的集群的命令如下：1kubeadm join 192.168.213.130:6443 --token 3lnb74.tku3cdu5bagn0air --discovery-token-ca-cert-hash sha256:2ba48ce20ebefcfb6d07ddf01141590eb81cad5de5c0406f08f41faab26a8696 token，一般token两天就过期了，如果过期了你需要重新创建（查看token命令是kubeadm token list，创建token命令是kubeadm token create)，如下： 123root@k8s-master:~# kubeadm token listTOKEN TTL EXPIRES USAGES DESCRIPTION EXTRA GROUPS3lnb74.tku3cdu5bagn0air 22h 2019-01-08T14:59:55+08:00 authentication,signing The default bootstrap token generated by &apos;kubeadm init&apos;. system:bootstrappers:kubeadm:default-node-token –discovery-token-ca-cert-hash，通过如下命令就可以得到 12root@k8s-master:~# openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed &apos;s/^.* //&apos;2ba48ce20ebefcfb6d07ddf01141590eb81cad5de5c0406f08f41faab26a8696 删除slave节点12kubectl drain &lt;node name&gt; --delete-local-data --force --ignore-daemonsetskubectl delete node &lt;node name&gt;","categories":[{"name":"好奇尚异","slug":"好奇尚异","permalink":"https://www.kikfan.com/categories/好奇尚异/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"https://www.kikfan.com/tags/k8s/"},{"name":"Kubernates","slug":"Kubernates","permalink":"https://www.kikfan.com/tags/Kubernates/"}]},{"title":"JFrame","slug":"JFrame","date":"2019-01-06T17:53:57.000Z","updated":"2019-01-20T08:22:32.000Z","comments":true,"path":"archives/ad1a6c7d.html","link":"","permalink":"https://www.kikfan.com/archives/ad1a6c7d.html","excerpt":"WindowMenu","text":"WindowMenu 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.gustave.practice.jframe;import javax.swing.*;public class WindowMenu extends JFrame &#123; JMenuBar menubar; JMenu menu0,menu1,menu2,subMenu; JMenuItem item1,item2,item3; public WindowMenu(String s,int x,int y,int w,int h) &#123; init(s); setLocation(x,y); setSize(w,h); setVisible(true); setDefaultCloseOperation(DISPOSE_ON_CLOSE); &#125; void init(String s) &#123; setTitle(s); menubar = new JMenuBar(); menu0 = new JMenu(\"游戏\"); //菜单栏的第一个选项 item1 = new JMenuItem(\"新游戏(new)\"); item2 = new JMenuItem(\"重新开始\"); menu0.add(item1); menu0.addSeparator(); //设置子菜单之间的分割线 menu0.add(item2); menu0.addSeparator(); //设置子菜单之间的分割线 subMenu = new JMenu(\"难度等级\"); menu0.add(subMenu); subMenu.add(new JMenuItem(\"初级\")); subMenu.add(new JMenuItem(\"中级\")); subMenu.add(new JMenuItem(\"高级\")); menu0.addSeparator(); item3 = new JMenuItem(\"退出\"); menu0.add(item3); menubar.add(menu0); menu1 = new JMenu(\"编辑\"); //菜单栏的第二个选项 item1 = new JMenuItem(\"后退一步\"); menu1.add(item1); menu1.addSeparator(); //设置子菜单之间的分割线 item2 = new JMenuItem(\"前进一步\"); menu1.add(item2); menubar.add(menu1); menu2 = new JMenu(\"关于\"); item1 = new JMenuItem(\"作者：rwxian\"); menu2.add(item1); menu2.addSeparator(); item2 = new JMenuItem(\"版本：v1.0\"); menu2.add(item2); menubar.add(menu2); setJMenuBar(menubar); &#125;&#125; Main1234567891011package com.gustave.practice.jframe;public class Main &#123; public static void main(String[] args) &#123; for (String arg : args) &#123; System.out.println(arg); &#125; WindowMenu win = new WindowMenu(\"俄罗斯方块\", 200, 30, 900, 1000); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://www.kikfan.com/categories/Java/"}],"tags":[{"name":"JFrame","slug":"JFrame","permalink":"https://www.kikfan.com/tags/JFrame/"},{"name":"Java","slug":"Java","permalink":"https://www.kikfan.com/tags/Java/"}]},{"title":"jenkins配置及使用","slug":"jenkins配置及使用","date":"2019-01-01T05:49:43.000Z","updated":"2019-01-04T17:32:03.000Z","comments":true,"path":"archives/adddc8ee.html","link":"","permalink":"https://www.kikfan.com/archives/adddc8ee.html","excerpt":"","text":"关于/var/run/docker.sock http方式创建和启动容器，帮助理解创建容器123curl -XPOST --unix-socket /var/run/docker.sock -d &apos;&#123;&quot;Image&quot;:&quot;redis&quot;&#125;&apos; -H &apos;Content-Type:application/json&apos; http://localhost/containers/create&#123;&quot;Id&quot;:&quot;773590db01d5061c9edb91ab258a2bfb537d00b76b74c695ff9cb7564b46d1c3&quot;,&quot;Warnings&quot;:null&#125; 启动容器1curl -XPOST --unix-socket /var/run/docker.sock http://localhost/containers/773590db01d5061c9edb91ab258a2bfb537d00b76b74c695ff9cb7564b46d1c3/start docker搭建jenkins docker-compose.yml 需要注意的是因为需求权限，所以添加root123456789101112version: '3.1'services: jenkins: restart: always image: jenkinsci/jenkins container_name: jenkins ports: - 8080:8080 volumes: - /usr/local/docker/jenkins/jenkinsci_home:/var/jenkins_home - /var/run/docker.sock:/var/run/docker.sock user: root","categories":[{"name":"好奇尚异","slug":"好奇尚异","permalink":"https://www.kikfan.com/categories/好奇尚异/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"https://www.kikfan.com/tags/jenkins/"}]},{"title":"JDK1.8Lambda、Stream及日期的使用整理","slug":"JDK1-8Lambda、Stream及日期的使用整理","date":"2018-12-22T01:22:26.000Z","updated":"2019-03-20T09:13:23.000Z","comments":true,"path":"archives/a6c4b5fd.html","link":"","permalink":"https://www.kikfan.com/archives/a6c4b5fd.html","excerpt":"","text":"前言本篇主要讲述是Java中JDK1.8的一些新语法特性使用，主要是Lambda、Stream和LocalDate日期的一些使用讲解。 LambdaLambda介绍Lambda 表达式(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。 Lambda表达式的结构一个 Lambda 表达式可以有零个或多个参数参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a, b) 或 (int a, int b) 或 (String a, int b, float c)空圆括号代表参数集为空。例如：() -&gt; 42当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：a -&gt; return a*aLambda 表达式的主体可包含零条或多条语句如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空Lambda 表达式的使用下面我们先使用一个简单的例子来看看Lambda的效果吧。 比如我们对Map 的遍历传统方式遍历如下:12345678910Map&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(\"a\", \"a\");map.put(\"b\", \"b\");map.put(\"c\", \"c\");map.put(\"d\", \"d\");System.out.println(\"map普通方式遍历:\");for (String key : map.keySet()) &#123; System.out.println(\"k=\" + key + \"，v=\" + map.get(key));&#125; 使用Lambda进行遍历:1234 System.out.println(\"map拉姆达表达式遍历:\"); map.forEach((k, v) -&gt; &#123; System.out.println(\"k=\" + k + \"，v=\" + v);&#125;); List也同理，不过List还可以通过双冒号运算符遍历:1234567891011List&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add(\"a\");list.add(\"bb\");list.add(\"ccc\");list.add(\"dddd\");System.out.println(\"list拉姆达表达式遍历:\");list.forEach(v -&gt; &#123; System.out.println(v);&#125;);System.out.println(\"list双冒号运算符遍历:\");list.forEach(System.out::println); 输出结果:123456789101112131415161718192021map普通方式遍历:k=a，v=ak=b，v=bk=c，v=ck=d，v=dmap拉姆达表达式遍历:k=a，v=ak=b，v=bk=c，v=ck=d，v=dlist拉姆达表达式遍历:abbcccddddlist双冒号运算符遍历:abbcccdddd Lambda除了在for循环遍历中使用外，它还可以代替匿名的内部类。比如下面这个例子的线程创建:1234567891011//使用普通的方式创建Runnable r1 = new Runnable() &#123; @Override public void run() &#123; System.out.println(\"普通方式创建!\"); &#125;&#125;;//使用拉姆达方式创建Runnable r2 = ()-&gt; System.out.println(\"拉姆达方式创建!\"); 注: 这个例子中使用Lambda表达式的时候，编译器会自动推断：根据线程类的构造函数签名 Runnable r { }，将该 Lambda 表达式赋Runnable 接口。 Lambda 表达式与匿名类的区别使用匿名类与 Lambda 表达式的一大区别在于关键词的使用。对于匿名类，关键词 this 解读为匿名类，而对于 Lambda 表达式，关键词 this 解读为写就 Lambda 的外部类。 Lambda表达式使用注意事项Lambda虽然简化了代码的编写，但同时也减少了可读性。 StreamStream介绍Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。 Stream特性： 不是数据结构： 它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。不支持索引访问： 但是很容易生成数组或者 List 。惰性化：很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。Intermediate 操作永远是惰性化的。并行能力。当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。可以是无限的：集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。注意事项：所有 Stream 的操作必须以 lambda 表达式为参数。Stream 流操作类型： Intermediate：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。 这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。Terminal：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。 所以这必定是流的最后一个操作。 Terminal操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。Stream使用这里我们依旧使用一个简单示例来看看吧。在开发中，我们有时需要对一些数据进行过滤，如果是传统的方式，我们需要对这批数据进行遍历过滤，会显得比较繁琐，如果使用steam流方式的话，那么可以很方便的进行处理。 首先通过普通的方式进行过滤:1234567891011121314List&lt;String&gt; list = Arrays.asList(\"张三\", \"李四\", \"王五\", \"xuwujing\"); System.out.println(\"过滤之前:\" + list); List&lt;String&gt; result = new ArrayList&lt;&gt;(); for (String str : list) &#123; if (!\"李四\".equals(str)) &#123; result.add(str); &#125; &#125; System.out.println(\"过滤之后:\" + result);使用Steam方式进行过滤：List&lt;String&gt; result2 = list.stream().filter(str -&gt; !\"李四\".equals(str)).collect(Collectors.toList());System.out.println(\"stream 过滤之后:\" + result2); 输出结果: 过滤之前:[张三, 李四, 王五, xuwujing]过滤之后:[张三, 王五, xuwujing]stream 过滤之后:[张三, 王五, xuwujing]是不是很简洁和方便呢。其实Stream流还有更多的使用方法，filter只是其中的一角而已。那么在这里我们就来学习了解下这些用法吧。 1.构造Stream流的方式1234567Stream stream = Stream.of(\"a\", \"b\", \"c\");String[] strArray = new String[] &#123; \"a\", \"b\", \"c\" &#125;;stream = Stream.of(strArray);stream = Arrays.stream(strArray);List&lt;String&gt; list = Arrays.asList(strArray);stream = list.stream(); 2.Stream流的之间的转换注意:一个Stream流只可以使用一次，这段代码为了简洁而重复使用了数次，因此会抛出 stream has already been operated upon or closed 异常。1234567891011121314151617try &#123; Stream&lt;String&gt; stream2 = Stream.of(\"a\", \"b\", \"c\"); // 转换成 Array String[] strArray1 = stream2.toArray(String[]::new); // 转换成 Collection List&lt;String&gt; list1 = stream2.collect(Collectors.toList()); List&lt;String&gt; list2 = stream2.collect(Collectors.toCollection(ArrayList::new)); Set set1 = stream2.collect(Collectors.toSet()); Stack stack1 = stream2.collect(Collectors.toCollection(Stack::new)); // 转换成 String String str = stream.collect(Collectors.joining()).toString(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 3.Stream流的map使用map方法用于映射每个元素到对应的结果，一对一。123456789101112131415161718192021示例一：转换大写 List&lt;String&gt; list3 = Arrays.asList(\"zhangSan\", \"liSi\", \"wangWu\"); System.out.println(\"转换之前的数据:\" + list3); List&lt;String&gt; list4 = list3.stream().map(String::toUpperCase).collect(Collectors.toList()); System.out.println(\"转换之后的数据:\" + list4); // 转换之后的数据:[ZHANGSAN, LISI,WANGWU]示例二：转换数据类型 List&lt;String&gt; list31 = Arrays.asList(\"1\", \"2\", \"3\"); System.out.println(\"转换之前的数据:\" + list31); List&lt;Integer&gt; list41 = list31.stream().map(Integer::valueOf).collect(Collectors.toList()); System.out.println(\"转换之后的数据:\" + list41); // [1, 2, 3]示例三：获取平方 List&lt;Integer&gt; list5 = Arrays.asList(new Integer[] &#123; 1, 2, 3, 4, 5 &#125;); List&lt;Integer&gt; list6 = list5.stream().map(n -&gt; n * n).collect(Collectors.toList()); System.out.println(\"平方的数据:\" + list6); // [1, 4, 9, 16, 25] 4.Stream流的filter使用filter方法用于通过设置的条件过滤出元素。1234567891011121314151617181920212223示例二：通过与 findAny 得到 if/else 的值List&lt;String&gt; list = Arrays.asList(\"张三\", \"李四\", \"王五\", \"xuwujing\");String result3 = list.stream().filter(str -&gt; \"李四\".equals(str)).findAny().orElse(\"找不到!\");String result4 = list.stream().filter(str -&gt; \"李二\".equals(str)).findAny().orElse(\"找不到!\");System.out.println(\"stream 过滤之后 2:\" + result3);System.out.println(\"stream 过滤之后 3:\" + result4);//stream 过滤之后 2:李四//stream 过滤之后 3:找不到!示例三：通过与 mapToInt 计算和 List&lt;User&gt; lists = new ArrayList&lt;User&gt;(); lists.add(new User(6, \"张三\")); lists.add(new User(2, \"李四\")); lists.add(new User(3, \"王五\")); lists.add(new User(1, \"张三\")); // 计算这个list中出现 \"张三\" id的值 int sum = lists.stream().filter(u -&gt; \"张三\".equals(u.getName())).mapToInt(u -&gt; u.getId()).sum(); System.out.println(\"计算结果:\" + sum); // 7 5.Stream流的flatMap使用flatMap 方法用于映射每个元素到对应的结果，一对多。12345678910111213141516示例:从句子中得到单词 String worlds = \"The way of the future\"; List&lt;String&gt; list7 = new ArrayList&lt;&gt;(); list7.add(worlds); List&lt;String&gt; list8 = list7.stream().flatMap(str -&gt; Stream.of(str.split(\" \"))) .filter(world -&gt; world.length() &gt; 0).collect(Collectors.toList()); System.out.println(\"单词:\"); list8.forEach(System.out::println); // 单词: // The // way // of // the // future 6.Stream流的limit使用limit 方法用于获取指定数量的流。1234567891011121314151617181920212223242526272829示例一：获取前n条数的数据 Random rd = new Random(); System.out.println(\"取到的前三条数据:\"); rd.ints().limit(3).forEach(System.out::println); // 取到的前三条数据: // 1167267754 // -1164558977 // 1977868798示例二：结合skip使用得到需要的数据skip表示的是扔掉前n个元素。List&lt;User&gt; list9 = new ArrayList&lt;User&gt;(); for (int i = 1; i &lt; 4; i++) &#123; User user = new User(i, \"pancm\" + i); list9.add(user); &#125; System.out.println(\"截取之前的数据:\"); // 取前3条数据，但是扔掉了前面的2条，可以理解为拿到的数据为 2&lt;=i&lt;3 (i 是数值下标) List&lt;String&gt; list10 = list9.stream().map(User::getName).limit(3).skip(2).collect(Collectors.toList()); System.out.println(\"截取之后的数据:\" + list10); // 截取之前的数据: // 姓名:pancm1 // 姓名:pancm2 // 姓名:pancm3 // 截取之后的数据:[pancm3]注:User实体类中 getName 方法会打印姓名。 7.Stream流的sort使用sorted方法用于对流进行升序排序。123456789101112131415161718192021222324示例一：随机取值排序 Random rd2 = new Random(); System.out.println(\"取到的前三条数据然后进行排序:\"); rd2.ints().limit(3).sorted().forEach(System.out::println); // 取到的前三条数据然后进行排序: // -2043456377 // -1778595703 // 1013369565示例二：优化排序tips:先获取在排序效率会更高! //普通的排序取值 List&lt;User&gt; list11 = list9.stream().sorted((u1, u2) -&gt; u1.getName().compareTo(u2.getName())).limit(3) .collect(Collectors.toList()); System.out.println(\"排序之后的数据:\" + list11); //优化排序取值 List&lt;User&gt; list12 = list9.stream().limit(3).sorted((u1, u2) -&gt; u1.getName().compareTo(u2.getName())) .collect(Collectors.toList()); System.out.println(\"优化排序之后的数据:\" + list12); //排序之后的数据:[&#123;\"id\":1,\"name\":\"pancm1\"&#125;, &#123;\"id\":2,\"name\":\"pancm2\"&#125;, &#123;\"id\":3,\"name\":\"pancm3\"&#125;] //优化排序之后的数据:[&#123;\"id\":1,\"name\":\"pancm1\"&#125;, &#123;\"id\":2,\"name\":\"pancm2\"&#125;, &#123;\"id\":3,\"name\":\"pancm3\"&#125;] 8.Stream流的peek使用peek对每个元素执行操作并返回一个新的Stream1234567891011示例:双重操作 System.out.println(\"peek使用:\"); Stream.of(\"one\", \"two\", \"three\", \"four\").filter(e -&gt; e.length() &gt; 3).peek(e -&gt; System.out.println(\"转换之前: \" + e)) .map(String::toUpperCase).peek(e -&gt; System.out.println(\"转换之后: \" + e)).collect(Collectors.toList()); // 转换之前: three // 转换之后: THREE // 转换之前: four // 转换之后: FOUR 9.Stream流的parallel使用parallelStream 是流并行处理程序的代替方法。1234567示例:获取空字符串的数量 List&lt;String&gt; strings = Arrays.asList(\"a\", \"\", \"c\", \"\", \"e\",\"\", \" \"); // 获取空字符串的数量 long count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count(); System.out.println(\"空字符串的个数:\"+count); 10.Stream流的max/min/distinct使用1234567891011121314151617示例一：得到最大最小值 List&lt;String&gt; list13 = Arrays.asList(\"zhangsan\",\"lisi\",\"wangwu\",\"xuwujing\"); int maxLines = list13.stream().mapToInt(String::length).max().getAsInt(); int minLines = list13.stream().mapToInt(String::length).min().getAsInt(); System.out.println(\"最长字符的长度:\" + maxLines+\",最短字符的长度:\"+minLines); //最长字符的长度:8,最短字符的长度:4示例二：得到去重之后的数据 String lines = \"good good study day day up\"; List&lt;String&gt; list14 = new ArrayList&lt;String&gt;(); list14.add(lines); List&lt;String&gt; words = list14.stream().flatMap(line -&gt; Stream.of(line.split(\" \"))).filter(word -&gt; word.length() &gt; 0) .map(String::toLowerCase).distinct().sorted().collect(Collectors.toList()); System.out.println(\"去重复之后:\" + words); //去重复之后:[day, good, study, up] 11.Stream流的Match使用allMatch：Stream 中全部元素符合则返回 true ;anyMatch：Stream 中只要有一个元素符合则返回 true;noneMatch：Stream 中没有一个元素符合则返回 true。123456789101112示例:数据是否符合 boolean all = lists.stream().allMatch(u -&gt; u.getId() &gt; 3); System.out.println(\"是否都大于3:\" + all); boolean any = lists.stream().anyMatch(u -&gt; u.getId() &gt; 3); System.out.println(\"是否有一个大于3:\" + any); boolean none = lists.stream().noneMatch(u -&gt; u.getId() &gt; 3); System.out.println(\"是否没有一个大于3的:\" + none); // 是否都大于3:false // 是否有一个大于3:true // 是否没有一个大于3的:false 12.Stream流的reduce使用reduce 主要作用是把 Stream 元素组合起来进行操作。12345678910111213141516171819202122232425示例一：字符串连接String concat = Stream.of(\"A\", \"B\", \"C\", \"D\").reduce(\"\", String::concat);System.out.println(\"字符串拼接:\" + concat);示例二：得到最小值 double minValue = Stream.of(-4.0, 1.0, 3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); System.out.println(\"最小值:\" + minValue); //最小值:-4.0示例三：求和 // 求和, 无起始值 int sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get(); System.out.println(\"有无起始值求和:\" + sumValue); // 求和, 有起始值 sumValue = Stream.of(1, 2, 3, 4).reduce(1, Integer::sum); System.out.println(\"有起始值求和:\" + sumValue); // 有无起始值求和:10 // 有起始值求和:11示例四：过滤拼接concat = Stream.of(\"a\", \"B\", \"c\", \"D\", \"e\", \"F\").filter(x -&gt; x.compareTo(\"Z\") &gt; 0).reduce(\"\", String::concat);System.out.println(\"过滤和字符串连接:\" + concat); //过滤和字符串连接:ace 13.Stream流的iterate使用iterate 跟 reduce 操作很像，接受一个种子值，和一个UnaryOperator（例如 f）。 然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。 在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。1234567示例:生成一个等差队列 System.out.println(\"从2开始生成一个等差队列:\"); Stream.iterate(2, n -&gt; n + 2).limit(5).forEach(x -&gt; System.out.print(x + \" \")); // 从2开始生成一个等差队列: // 2 4 6 8 10 14.Stream流的Supplier使用通过实现Supplier类的方法可以自定义流计算规则。 示例：随机获取两条用户信息123456789101112131415161718192021222324252627 System.out.println(\"自定义一个流进行计算输出:\"); Stream.generate(new UserSupplier()).limit(2).forEach(u -&gt; System.out.println(u.getId() + \", \" + u.getName())); //第一次: //自定义一个流进行计算输出: //10, pancm7 //11, pancm6 //第二次: //自定义一个流进行计算输出: //10, pancm4 //11, pancm2 //第三次: //自定义一个流进行计算输出: //10, pancm4 //11, pancm8class UserSupplier implements Supplier&lt;User&gt; &#123; private int index = 10; private Random random = new Random(); @Override public User get() &#123; return new User(index++, \"pancm\" + random.nextInt(10)); &#125; } 15.Stream流的groupingBy/partitioningBy使用groupingBy：分组排序；partitioningBy：分区排序。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849示例一：分组排序 System.out.println(\"通过id进行分组排序:\"); Map&lt;Integer, List&lt;User&gt;&gt; personGroups = Stream.generate(new UserSupplier2()).limit(5) .collect(Collectors.groupingBy(User::getId)); Iterator it = personGroups.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;Integer, List&lt;User&gt;&gt; persons = (Map.Entry) it.next(); System.out.println(\"id \" + persons.getKey() + \" = \" + persons.getValue()); &#125; // 通过id进行分组排序: // id 10 = [&#123;\"id\":10,\"name\":\"pancm1\"&#125;] // id 11 = [&#123;\"id\":11,\"name\":\"pancm3\"&#125;, &#123;\"id\":11,\"name\":\"pancm6\"&#125;, &#123;\"id\":11,\"name\":\"pancm4\"&#125;, &#123;\"id\":11,\"name\":\"pancm7\"&#125;] class UserSupplier2 implements Supplier&lt;User&gt; &#123; private int index = 10; private Random random = new Random(); @Override public User get() &#123; return new User(index % 2 == 0 ? index++ : index, \"pancm\" + random.nextInt(10)); &#125; &#125;示例二：分区排序 System.out.println(\"通过年龄进行分区排序:\"); Map&lt;Boolean, List&lt;User&gt;&gt; children = Stream.generate(new UserSupplier3()).limit(5) .collect(Collectors.partitioningBy(p -&gt; p.getId() &lt; 18)); System.out.println(\"小孩: \" + children.get(true)); System.out.println(\"成年人: \" + children.get(false)); // 通过年龄进行分区排序: // 小孩: [&#123;\"id\":16,\"name\":\"pancm7\"&#125;, &#123;\"id\":17,\"name\":\"pancm2\"&#125;] // 成年人: [&#123;\"id\":18,\"name\":\"pancm4\"&#125;, &#123;\"id\":19,\"name\":\"pancm9\"&#125;, &#123;\"id\":20,\"name\":\"pancm6\"&#125;] class UserSupplier3 implements Supplier&lt;User&gt; &#123; private int index = 16; private Random random = new Random(); @Override public User get() &#123; return new User(index++, \"pancm\" + random.nextInt(10)); &#125; &#125; 16.Stream流的summaryStatistics使用IntSummaryStatistics 用于收集统计信息(如count、min、max、sum和average)的状态对象。123456789101112131415示例:得到最大、最小、之和以及平均数。 List&lt;Integer&gt; numbers = Arrays.asList(1, 5, 7, 3, 9); IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics(); System.out.println(\"列表中最大的数 : \" + stats.getMax()); System.out.println(\"列表中最小的数 : \" + stats.getMin()); System.out.println(\"所有数之和 : \" + stats.getSum()); System.out.println(\"平均数 : \" + stats.getAverage()); // 列表中最大的数 : 9 // 列表中最小的数 : 1 // 所有数之和 : 25 // 平均数 : 5.0 Stream 介绍就到这里了，JDK1.8中的Stream流其实还有很多很多用法，更多的用法则需要大家去查看JDK1.8的API文档了。 LocalDateTime介绍JDK1.8除了新增了lambda表达式、stream流之外，它还新增了全新的日期时间API。在JDK1.8之前，Java处理日期、日历和时间的方式一直为社区所诟病，将 java.util.Date设定为可变类型，以及SimpleDateFormat的非线程安全使其应用非常受限。因此推出了java.time包，该包下的所有类都是不可变类型而且线程安全。 关键类Instant：瞬时时间。LocalDate：本地日期，不包含具体时间, 格式 yyyy-MM-dd。LocalTime：本地时间，不包含日期. 格式 yyyy-MM-dd HH:mm:ss.SSS 。LocalDateTime：组合了日期和时间，但不包含时差和时区信息。ZonedDateTime：最完整的日期时间，包含时区和相对UTC或格林威治的时差。使用 1.获取当前的日期时间通过静态工厂方法now()来获取当前时间。123456789//本地日期,不包括时分秒LocalDate nowDate = LocalDate.now();//本地日期,包括时分秒LocalDateTime nowDateTime = LocalDateTime.now();System.out.println(\"当前时间:\"+nowDate);System.out.println(\"当前时间:\"+nowDateTime);// 当前时间:2018-12-19// 当前时间:2018-12-19T15:24:35.822 2.获取当前的年月日时分秒获取时间之后，直接get获取年月日时分秒。123456789101112131415 //获取当前的时间，包括毫秒 LocalDateTime ldt = LocalDateTime.now(); System.out.println(\"当前年:\"+ldt.getYear()); //2018 System.out.println(\"当前年份天数:\"+ldt.getDayOfYear());//172 System.out.println(\"当前月:\"+ldt.getMonthValue()); System.out.println(\"当前时:\"+ldt.getHour()); System.out.println(\"当前分:\"+ldt.getMinute()); System.out.println(\"当前时间:\"+ldt.toString());// 当前年:2018// 当前年份天数:353// 当前月:12// 当前时:15// 当前分:24// 当前时间:2018-12-19T15:24:35.833 3.格式化时间格式时间格式需要用到DateTimeFormatter类。1234LocalDateTime ldt = LocalDateTime.now();System.out.println(\"格式化时间: \"+ ldt.format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss.SSS\")));//格式化时间:2018-12-19 15:37:47.119 4.时间增减在指定的时间进行增加/减少年月日时分秒。123456789101112 LocalDateTime ldt = LocalDateTime.now(); System.out.println(\"后5天时间:\"+ldt.plusDays(5)); System.out.println(\"前5天时间并格式化:\"+ldt.minusDays(5).format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd\"))); //2018-06-16 System.out.println(\"前一个月的时间:\"+ldt2.minusMonths(1).format(DateTimeFormatter.ofPattern(\"yyyyMM\"))); //2018-06-16 System.out.println(\"后一个月的时间:\"+ldt2.plusMonths(1)); //2018-06-16 System.out.println(\"指定2099年的当前时间:\"+ldt.withYear(2099)); //2099-06-21T15:07:39.506// 后5天时间:2018-12-24T15:50:37.508// 前5天时间并格式化:2018-12-14// 前一个月的时间:201712// 后一个月的时间:2018-02-04T09:19:29.499// 指定2099年的当前时间:2099-12-19T15:50:37.508 5.创建指定时间通过指定年月日来创建。123LocalDate ld3=LocalDate.of(2017, Month.NOVEMBER, 17);LocalDate ld4=LocalDate.of(2018, 02, 11); 6.时间相差比较比较相差的年月日时分秒。 示例一: 具体相差的年月日123456LocalDate ld=LocalDate.parse(\"2017-11-17\");LocalDate ld2=LocalDate.parse(\"2018-01-05\");Period p=Period.between(ld, ld2);System.out.println(\"相差年: \"+p.getYears()+\" 相差月 :\"+p.getMonths() +\" 相差天:\"+p.getDays());// 相差年: 0 相差月 :1 相差天:19 注:这里的月份是不满足一年，天数是不满足一个月的。这里实际相差的是1月19天，也就是49天。 示例二：相差总数的时间 ChronoUnit 日期周期单位的标准集合。1234567LocalDate startDate = LocalDate.of(2017, 11, 17);LocalDate endDate = LocalDate.of(2018, 01, 05);System.out.println(\"相差月份:\"+ChronoUnit.MONTHS.between(startDate, endDate));System.out.println(\"两月之间的相差的天数 : \" + ChronoUnit.DAYS.between(startDate, endDate));// 相差月份:1// 两天之间的差在天数 : 49 注:ChronoUnit也可以计算相差时分秒。 示例三：精度时间相差 Duration 这个类以秒和纳秒为单位建模时间的数量或数量。1234567891011Instant inst1 = Instant.now();System.out.println(\"当前时间戳 : \" + inst1);Instant inst2 = inst1.plus(Duration.ofSeconds(10));System.out.println(\"增加之后的时间 : \" + inst2);System.out.println(\"相差毫秒 : \" + Duration.between(inst1, inst2).toMillis());System.out.println(\"相毫秒 : \" + Duration.between(inst1, inst2).getSeconds());// 当前时间戳 : 2018-12-19T08:14:21.675Z// 增加之后的时间 : 2018-12-19T08:14:31.675Z// 相差毫秒 : 10000// 相毫秒 : 10 示例四：时间大小比较1234567LocalDateTime ldt4 = LocalDateTime.now();LocalDateTime ldt5 = ldt4.plusMinutes(10);System.out.println(\"当前时间是否大于:\"+ldt4.isAfter(ldt5));System.out.println(\"当前时间是否小于\"+ldt4.isBefore(ldt5));// false// true 7.时区时间计算得到其他时区的时间。 示例一:通过Clock时钟类获取计算 Clock时钟类用于获取当时的时间戳，或当前时区下的日期时间信息。12345678910Clock clock = Clock.systemUTC();System.out.println(\"当前时间戳 : \" + clock.millis());Clock clock2 = Clock.system(ZoneId.of(\"Asia/Shanghai\"));System.out.println(\"亚洲上海此时的时间戳:\"+clock2.millis());Clock clock3 = Clock.system(ZoneId.of(\"America/New_York\"));System.out.println(\"美国纽约此时的时间戳:\"+clock3.millis());// 当前时间戳 : 1545209277657// 亚洲上海此时的时间戳:1545209277657// 美国纽约此时的时间戳:1545209277658 示例二:通过ZonedDateTime类和ZoneId1234567ZoneId zoneId= ZoneId.of(\"America/New_York\");ZonedDateTime dateTime=ZonedDateTime.now(zoneId);System.out.println(\"美国纽约此时的时间 : \" + dateTime.format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss.SSS\")));System.out.println(\"美国纽约此时的时间 和时区: \" + dateTime);// 美国纽约此时的时间 : 2018-12-19 03:52:22.494// 美国纽约此时的时间 和时区: 2018-12-19T03:52:22.494-05:00[America/New_York] Java 8日期时间API总结: 提供了javax.time.ZoneId 获取时区。提供了LocalDate和LocalTime类。Java 8 的所有日期和时间API都是不可变类并且线程安全，而现有的Date和Calendar API中的java.util.Date和SimpleDateFormat是非线程安全的。主包是 java.time,包含了表示日期、时间、时间间隔的一些类。里面有两个子包java.time.format用于格式化， java.time.temporal用于更底层的操作。时区代表了地球上某个区域内普遍使用的标准时间。每个时区都有一个代号，格式通常由区域/城市构成（Asia/Tokyo），在加上与格林威治或 UTC的时差。例如：东京的时差是+09:00。OffsetDateTime类实际上组合了LocalDateTime类和ZoneOffset类。用来表示包含和格林威治或UTC时差的完整日期（年、月、日）和时间（时、分、秒、纳秒）信息。DateTimeFormatter 类用来格式化和解析时间。与SimpleDateFormat不同，这个类不可变并且线程安全，需要时可以给静态常量赋值。 DateTimeFormatter类提供了大量的内置格式化工具，同时也允许你自定义。在转换方面也提供了parse()将字符串解析成日期，如果解析出错会抛出DateTimeParseException。DateTimeFormatter类同时还有format()用来格式化日期，如果出错会抛出DateTimeException异常。再补充一点，日期格式“MMM d yyyy”和“MMM dd yyyy”有一些微妙的不同，第一个格式可以解析“Jan 2 2014”和“Jan 14 2014”，而第二个在解析“Jan 2 2014”就会抛异常，因为第二个格式里要求日必须是两位的。如果想修正，你必须在日期只有个位数时在前面补零，就是说“Jan 2 2014”应该写成 “Jan 02 2014”。 利用lambda以及Compartor接口进行排序 对于有多个字段得排序，这样的方式就更加方便一点12345678910111213141516@Test public void testLambda()&#123; List&lt;StudentCourse&gt; list = new ArrayList&lt;&gt;(); int[][] nums = new int[][]&#123;&#123;1, 4, 88&#125;, &#123;8, 4, 7&#125;, &#123;8, 2, 9&#125;, &#123;8, 2, 88&#125;&#125;; for (int i = 0; i &lt; nums.length; i++) &#123; StudentCourse course = new StudentCourse(); course.setSid(nums[i][0]); course.setCid(nums[i][1]); course.setScore(nums[i][2]); list.add(course); &#125; list.sort(Comparator.comparing(StudentCourse::getSid).reversed() .thenComparing((s1,s2)-&gt;s2.getCid().compareTo(s1.getCid())) .thenComparing(StudentCourse::getScore)); list.forEach(System.out::println); &#125; 1234StudentCourse(sid=8, cid=4, score=7)StudentCourse(sid=8, cid=2, score=9)StudentCourse(sid=8, cid=2, score=88)StudentCourse(sid=1, cid=4, score=88) 转自: http://www.cnblogs.com/xuwujing","categories":[{"name":"Java","slug":"Java","permalink":"https://www.kikfan.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.kikfan.com/tags/Java/"},{"name":"Lambda","slug":"Lambda","permalink":"https://www.kikfan.com/tags/Lambda/"},{"name":"Stream","slug":"Stream","permalink":"https://www.kikfan.com/tags/Stream/"}]},{"title":"redis","slug":"redis配置及命令大全","date":"2018-12-08T13:58:54.000Z","updated":"2019-01-01T05:47:53.000Z","comments":true,"path":"archives/9494c549.html","link":"","permalink":"https://www.kikfan.com/archives/9494c549.html","excerpt":"","text":"time flies redis最近略忙，都没时间搞了，冒个泡我的自信和自负皆源自于此，如此一直下去就可以了即将更新，redis！！ redis连踩两天坑，终于搞定！！爽 pom依赖 由于spring版本的问题，踩了几多坑，找到合适的版本12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.8.11.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;biz.paluch.redis&lt;/groupId&gt; &lt;artifactId&gt;lettuce&lt;/artifactId&gt; &lt;version&gt;4.2.0.Final&lt;/version&gt;&lt;/dependency&gt; redis.properties 使用的哨兵模式12345678redis.nodes=192.168.213.129:26379,192.168.213.129:26380,192.168.213.129:26381redis.masterName=mymasterredis.password=redis.maxTotal=10000redis.maxIdle=100redis.minIdle=50redis.timeout=30000redis.database=6 applicationContext-redis.xml 使用lettuce操作redis 更改了序列化方式，可以直接查看redis里的数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jee=\"http://www.springframework.org/schema/jee\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.1.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd \"&gt; &lt;!--连接池配置--&gt; &lt;bean id=\"defaultLettucePool\" class=\"org.springframework.data.redis.connection.lettuce.DefaultLettucePool\"&gt; &lt;constructor-arg name=\"sentinelConfiguration\" ref=\"lettuceSentinelConfiguration\"/&gt; &lt;property name=\"poolConfig\" ref=\"genericObjectPoolConfig\"/&gt; &lt;/bean&gt; &lt;!--common-pool2线程池配置--&gt; &lt;bean id=\"genericObjectPoolConfig\" class=\"org.apache.commons.pool2.impl.GenericObjectPoolConfig\"&gt; &lt;property name=\"maxIdle\" value=\"$&#123;redis.maxIdle&#125;\"/&gt; &lt;property name=\"minIdle\" value=\"$&#123;redis.minIdle&#125;\"/&gt; &lt;property name=\"maxTotal\" value=\"$&#123;redis.maxTotal&#125;\"/&gt; &lt;!-- 其他相关配置 --&gt; &lt;/bean&gt; &lt;!--哨兵集群信息配置--&gt; &lt;bean id=\"lettuceSentinelConfiguration\" class=\"org.springframework.data.redis.connection.RedisSentinelConfiguration\"&gt; &lt;constructor-arg name=\"master\" value=\"$&#123;redis.masterName&#125;\"/&gt; &lt;constructor-arg name=\"sentinelHostAndPorts\" value=\"$&#123;redis.nodes&#125;\"/&gt; &lt;/bean&gt; &lt;bean id=\"lettuceConnectionFactory\" class=\"org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory\"&gt; &lt;!--注销掉的部分为spring-data-redis2.0以下的版本配置的方式--&gt; &lt;!--&lt;constructor-arg name=\"sentinelConfiguration\" ref=\"lettuceSentinelConfiguration\"/&gt;--&gt; &lt;constructor-arg name=\"pool\" ref=\"defaultLettucePool\"/&gt; &lt;property name=\"database\" value=\"$&#123;redis.database&#125;\"/&gt; &lt;!--spring-data-redis2.0以上建议获取的方式--&gt; &lt;!--&lt;constructor-arg name=\"standaloneConfig\" ref=\"redisStandaloneConfiguration\"&gt;&lt;/constructor-arg&gt;--&gt; &lt;/bean&gt; &lt;!--手动设置 key 与 value的序列化方式--&gt; &lt;bean id=\"keySerializer\" class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"/&gt; &lt;bean id=\"valueSerializer\" class=\"org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer\"/&gt; &lt;!--配置jedis模板 --&gt; &lt;bean id = \"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"lettuceConnectionFactory\" /&gt; &lt;property name=\"keySerializer\" ref=\"keySerializer\" /&gt; &lt;property name=\"valueSerializer\" ref=\"valueSerializer\" /&gt; &lt;property name=\"hashKeySerializer\" ref=\"keySerializer\" /&gt; &lt;property name=\"hashValueSerializer\" ref=\"valueSerializer\" /&gt; &lt;/bean&gt; &lt;!--也可以StringRedisTemplate 专注于String的操作 --&gt; &lt;bean id=\"stringRedisTemplate\" class=\"org.springframework.data.redis.core.StringRedisTemplate\"&gt; &lt;!--&lt;property name=\"connectionFactory\" ref=\"jedisConnectionFactory\"&gt;&lt;/property&gt;--&gt; &lt;!--在StringRedisTemplate与redisTemplate不同,可以直接造构造器中传入ConnectionFactory--&gt; &lt;constructor-arg name=\"connectionFactory\" ref=\"lettuceConnectionFactory\"/&gt; &lt;property name=\"keySerializer\" ref=\"keySerializer\" /&gt; &lt;property name=\"valueSerializer\" ref=\"valueSerializer\" /&gt; &lt;property name=\"hashKeySerializer\" ref=\"keySerializer\" /&gt; &lt;property name=\"hashValueSerializer\" ref=\"valueSerializer\" /&gt; &lt;/bean&gt;&lt;/beans&gt; Redis操作命令连接操作相关的命令 ping：测试连接是否存活如果正常会返回 pong echo：打印 select：切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值 quit：关闭连接（connection） auth：简单密码认证服务端相关命令 time：返回当前服务器时间 client list: 返回所有连接到服务器的客户端信息和统计数据 参见 http://redisdoc.com/server/client_list.html client kill ip:port：关闭地址为 ip:port 的客户端 save：将数据同步保存到磁盘 bgsave：将数据异步保存到磁盘 lastsave：返回上次成功将数据保存到磁盘的Unix时戳 shundown：将数据同步保存到磁盘，然后关闭服务 info：提供服务器的信息和统计 config resetstat：重置 info 命令中的某些统计数据 config get：获取配置文件信息 config set：动态地调整 Redis 服务器的配置(configuration)而无须重启，可以修改的配置参数可以使用命令 CONFIG GET * 来列出 config rewrite：Redis 服务器时所指定的 redis.conf 文件进行改写 monitor：实时转储收到的请求 slaveof：改变复制策略设置发布订阅相关命令 psubscribe：订阅一个或多个符合给定模式的频道 例如 psubscribe news. tweet. publish：将信息 message 发送到指定的频道 channel 例如 publish msg “good morning” pubsub channels：列出当前的活跃频道 例如 PUBSUB CHANNELS news.i* pubsub numsub：返回给定频道的订阅者数量 例如 PUBSUB NUMSUB news.it news.internet news.sport news.music pubsub numpat：返回客户端订阅的所有模式的数量总和 punsubscribe：指示客户端退订所有给定模式。 subscribe：订阅给定的一个或多个频道的信息。例如 subscribe msg chat_room unsubscribe：指示客户端退订给定的频道。对 KEY 操作的命令 exists(key)：确认一个 key 是否存在 del(key)：删除一个 key type(key)：返回值的类型 keys(pattern)：返回满足给定 pattern 的所有 key randomkey：随机返回 key 空间的一个 keyrename(oldname, newname)：重命名 key dbsize：返回当前数据库中 key 的数目 expire：设定一个 key 的活动时间（s） ttl：获得一个 key 的活动时间 move(key, dbindex)：移动当前数据库中的 key 到 dbindex 数据库 flushdb：删除当前选择数据库中的所有 key flushall：删除所有数据库中的所有 key对 String 操作的命令 set(key, value)：给数据库中名称为 key 的 string 赋予值 value get(key)：返回数据库中名称为 key 的 string 的 value getset(key, value)：给名称为 key 的 string 赋予上一次的 value mget(key1, key2,…, key N)：返回库中多个 string 的 value setnx(key, value)：添加 string，名称为 key，值为 value setex(key, time, value)：向库中添加 string，设定过期时间 time mset(key N, value N)：批量设置多个 string 的值 msetnx(key N, value N)：如果所有名称为 key i 的 string 都不存在 incr(key)：名称为 key 的 string 增 1 操作 incrby(key, integer)：名称为 key 的 string 增加 integer decr(key)：名称为 key 的 string 减 1 操作 decrby(key, integer)：名称为 key 的 string 减少 integer append(key, value)：名称为 key 的 string 的值附加 value substr(key, start, end)：返回名称为 key 的 string 的 value 的子串对 List 操作的命令 rpush(key, value)：在名称为 key 的 list 尾添加一个值为 value 的元素 lpush(key, value)：在名称为 key 的 list 头添加一个值为 value 的元素 llen(key)：返回名称为 key 的 list 的长度 lrange(key, start, end)：返回名称为 key 的 list 中 start 至 end 之间的元素 ltrim(key, start, end)：截取名称为 key 的 list lindex(key, index)：返回名称为 key 的 list 中 index 位置的元素 lset(key, index, value)：给名称为 key 的 list 中 index 位置的元素赋值 lrem(key, count, value)：删除 count 个 key 的 list 中值为 value 的元素 lpop(key)：返回并删除名称为 key 的 list 中的首元素 rpop(key)：返回并删除名称为 key 的 list 中的尾元素 blpop(key1, key2,… key N, timeout)：lpop 命令的 block 版本。 brpop(key1, key2,… key N, timeout)：rpop 的 block 版本。 rpoplpush(srckey, dstkey)：返回并删除名称为 srckey 的 list 的尾元素，并将该元素添加到名称为 dstkey 的 list 的头部对 Set 操作的命令 sadd(key, member)：向名称为 key 的 set 中添加元素 member srem(key, member) ：删除名称为 key 的 set 中的元素 member spop(key) ：随机返回并删除名称为 key 的 set 中一个元素 smove(srckey, dstkey, member) ：移到集合元素 scard(key) ：返回名称为 key 的 set 的基数 sismember(key, member) ：member 是否是名称为 key 的 set 的元素 sinter(key1, key2,…key N) ：求交集 sinterstore(dstkey, (keys)) ：求交集并将交集保存到 dstkey 的集合 sunion(key1, (keys)) ：求并集 sunionstore(dstkey, (keys)) ：求并集并将并集保存到 dstkey 的集合 sdiff(key1, (keys)) ：求差集 sdiffstore(dstkey, (keys)) ：求差集并将差集保存到 dstkey 的集合 smembers(key) ：返回名称为 key 的 set 的所有元素 srandmember(key) ：随机返回名称为 key 的 set 的一个元素对 Hash 操作的命令 hset(key, field, value)：向名称为 key 的 hash 中添加元素 field hget(key, field)：返回名称为 key 的 hash 中 field 对应的 value hmget(key, (fields))：返回名称为 key 的 hash 中 field i 对应的 value hmset(key, (fields))：向名称为 key 的 hash 中添加元素 field hincrby(key, field, integer)：将名称为 key 的 hash 中 field 的 value 增加 integer hexists(key, field)：名称为 key 的 hash 中是否存在键为 field 的域 hdel(key, field)：删除名称为 key 的 hash 中键为 field 的域 hlen(key)：返回名称为 key 的 hash 中元素个数 hkeys(key)：返回名称为 key 的 hash 中所有键 hvals(key)：返回名称为 key 的 hash 中所有键对应的 value hgetall(key)：返回名称为 key 的 hash 中所有的键（field）及其对应的 valueRedis Sentinel ping ：返回 pong sentinel masters ：列出所有被监视的主服务器，以及这些主服务器的当前状态。 sentinel slaves：列出给定主服务器的所有从服务器，以及这些从服务器的当前状态。 sentinel get-master-addr-by-name：返回给定名字的主服务器的 IP 地址和端口号。如果这个主服务器正在执行故障转移操作，或者针对这个主服务器的故障转移操作已经完成，那么这个命令返回新的主服务器的 IP 地址和端口号。 sentinel reset：重置所有名字和给定模式 pattern 相匹配的主服务器。pattern 参数是一个 Glob 风格的模式 重置操作清楚主服务器目前的所有状态，包括正在执行中的故障转移，并移除目前已经发现和关联的，主服务器的所有从服务器和 Sentinel 。 sentinel failover：当主服务器失效时，在不询问其他 Sentinel 意见的情况下，强制开始一次自动故障迁移（不过发起故障转移的 Sentinel 会向其他 Sentinel 发送一个新的配置，其他 Sentinel 会根据这个配置进行相应的更新）。","categories":[{"name":"好奇尚异","slug":"好奇尚异","permalink":"https://www.kikfan.com/categories/好奇尚异/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://www.kikfan.com/tags/redis/"}]},{"title":"Idea快捷键及IdeaVim","slug":"Idea快捷键及IdeaVim","date":"2018-12-03T14:08:52.000Z","updated":"2018-12-07T15:43:16.000Z","comments":true,"path":"archives/afc449e8.html","link":"","permalink":"https://www.kikfan.com/archives/afc449e8.html","excerpt":"","text":"Idea快捷键一览 Ctrl+Shift + Enter，语句完成 “！”，否定完成，输入表达式时按 “！”键 Ctrl+E，最近的文件 Ctrl+Shift+E，最近更改的文件 Shift+Click，可以关闭文件 Ctrl+[ OR ]，可以跑到大括号的开头与结尾 Ctrl+F12，可以显示当前文件的结构 Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择 Ctrl+N，可以快速打开类 Ctrl+Shift+N，可以快速打开文件 Alt+Q，可以看到当前方法的声明 Ctrl+P，可以显示参数信息 Ctrl+Shift+Insert，可以选择剪贴板内容并插入 Alt+Insert，可以生成构造器/Getter/Setter等 Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch Ctrl+Enter，导入包，自动修正 Ctrl+Alt+L，格式化代码 Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作 Ctrl+Alt+O，优化导入的类和包 Ctrl+R，替换文本 Ctrl+F，查找文本 Ctrl+Shift+Space，自动补全代码 Ctrl+空格，代码提示（与系统输入法快捷键冲突） Ctrl+Shift+Alt+N，查找类中的方法或变量 Alt+Shift+C，最近的更改 Alt+Shift+Up/Down，上/下移一行 Shift+F6，重构 – 重命名 Ctrl+X，删除行 Ctrl+D，复制行 Ctrl+/或Ctrl+Shift+/，注释（//或者/**/） Ctrl+J，自动代码（例如：serr） Ctrl+Alt+J，用动态模板环绕 Ctrl+H，显示类结构图（类的继承层次） Ctrl+Q，显示注释文档 Alt+F1，查找代码所在位置 Alt+1，快速打开或隐藏工程面板 Ctrl+Alt+left/right，返回至上次浏览的位置 Alt+left/right，切换代码视图 Alt+Up/Down，在方法间快速移动定位 Ctrl+Shift+Up/Down，向上/下移动语句 F2 或 Shift+F2，高亮错误或警告快速定位 Tab，代码标签输入完成后，按 Tab，生成代码 Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失 Alt+F3，逐个往下查找相同文本，并高亮显示 Ctrl+Up/Down，光标中转到第一行或最后一行下 Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处） Ctrl+Alt+B，跳转到方法实现处 Ctrl+Shift+Backspace，跳转到上次编辑的地方 Ctrl+O，重写方法 Ctrl+Alt+Space，类名自动完成 Ctrl+Alt+Up/Down，快速跳转搜索结果 Ctrl+Shift+J，整合两行 Alt+F8，计算变量值 Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本 Ctrl+Alt+Shift+V，简单粘贴 Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口 F12，把焦点从编辑器移到最近使用的工具窗口 Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器 Ctrl+W，可以选择单词继而语句继而行继而函数 Ctrl+Shift+W，取消选择光标所在词 Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置 Ctrl+I，实现方法 Ctrl+Shift+U，大小写转化 Ctrl+Y，删除当前行 Shift+Enter，向下插入新行 psvm/sout，main/System.out.println(); Ctrl+J，查看更多 Ctrl+Shift+F，全局查找 Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找 Ctrl+Shift+S，高级搜索 Ctrl+U，转到父类 Ctrl+Alt+S，打开设置对话框 Alt+Shift+Inert，开启/关闭列选择模式 Ctrl+Alt+Shift+S，打开当前项目/模块属性 Ctrl+G，定位行 Alt+Home，跳转到导航栏 Ctrl+Enter，上插一行 Ctrl+Backspace，按单词删除 Ctrl+”+/-”，当前方法展开、折叠 Ctrl+Shift+”+/-”，全部展开、折叠 【调试部分、编译】 Ctrl+F2，停止 Alt+Shift+F9，选择 Debug Alt+Shift+F10，选择 Run Ctrl+Shift+F9，编译 Ctrl+Shift+F10，运行 Ctrl+Shift+F8，查看断点 F8，步过 F7，步入 Shift+F7，智能步入 Shift+F8，步出 Alt+Shift+F8，强制步过 Alt+Shift+F7，强制步入 Alt+F9，运行至光标处 Ctrl+Alt+F9，强制运行至光标处 F9，恢复程序 Alt+F10，定位到断点 Ctrl+F8，切换行断点 Ctrl+F9，生成项目 Alt+1，项目 Alt+2，收藏 Alt+6，TODO Alt+7，结构 Ctrl+Shift+C，复制路径 Ctrl+Alt+Shift+C，复制引用，必须选择类名 Ctrl+Alt+Y，同步 Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） Shift+F12，还原默认布局 Ctrl+Shift+F12，隐藏/恢复所有窗口 Ctrl+F4，关闭 Ctrl+Shift+F4，关闭活动选项卡 Ctrl+Tab，转到下一个拆分器 Ctrl+Shift+Tab，转到上一个拆分器 【重构】 Ctrl+Alt+Shift+T，弹出重构菜单 Shift+F6，重命名 F6，移动 F5，复制 Alt+Delete，安全删除 Ctrl+Alt+N，内联 【查找】 Ctrl+F，查找 Ctrl+R，替换 F3，查找下一个 Shift+F3，查找上一个 Ctrl+Shift+F，在路径中查找 Ctrl+Shift+R，在路径中替换 Ctrl+Shift+S，搜索结构 Ctrl+Shift+M，替换结构 Alt+F7，查找用法 Ctrl+Alt+F7，显示用法 Ctrl+F7，在文件中查找用法 Ctrl+Shift+F7，在文件中高亮显示用法 转自:http://www.open-open.com/lib/view/open1396578860887.html 最常用快捷键 1.Ctrl＋E，可以显示最近编辑的文件列表 2.Shift＋Click可以关闭文件 3.Ctrl＋[或]可以跳到大括号的开头结尾 4.Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方 5.Ctrl＋F12，可以显示当前文件的结构 6.Ctrl＋F7可以查询当前元素在当前文件中的引用，然后按F3可以选择 7.Ctrl＋N，可以快速打开类 8.Ctrl＋Shift＋N，可以快速打开文件 9.Alt＋Q可以看到当前方法的声明 10.Ctrl＋W可以选择单词继而语句继而行继而函数 11.Alt＋F1可以将正在编辑的元素在各个面板中定位 12.Ctrl＋P，可以显示参数信息 13.Ctrl＋Shift＋Insert可以选择剪贴板内容并插入 14.Alt＋Insert可以生成构造器/Getter/Setter等 15.Ctrl＋Alt＋V 可以引入变量。例如把括号内的SQL赋成一个变量 16.Ctrl＋Alt＋T可以把代码包在一块内，例如try/catch 17.Alt＋Up and Alt＋Down可在方法间快速移动 下面的不是很有用 18.在一些地方按Alt＋Enter可以得到一些Intention Action，例如将”==”改为”equals()” 19.Ctrl＋Shift＋Alt＋N可以快速打开符号 20.Ctrl＋Shift＋Space在很多时候都能够给出Smart提示 21.Alt＋F3可以快速寻找 22.Ctrl＋/和Ctrl＋Shift＋/可以注释代码 23.Ctrl＋Alt＋B可以跳转到抽象方法的实现 24.Ctrl＋O可以选择父类的方法进行重写 25.Ctrl＋Q可以看JavaDoc 26.Ctrl＋Alt＋Space是类名自动完成 27.快速打开类/文件/符号时，可以使用通配符，也可以使用缩写 28.Live Templates! Ctrl＋J 29.Ctrl＋Shift＋F7可以高亮当前元素在当前文件中的使用 30.Ctrl＋Alt＋Up /Ctrl＋Alt＋Down可以快速跳转搜索结果 31.Ctrl＋Shift＋J可以整合两行 32.Alt＋F8是计算变量值 Ctrl + Shift +F11 标记该行代码，加入书签 Shift + F11 打开书签 Ctrl + Shift + Alt + F11 有符号的标记 Ctrl+ 刚刚选择的标记 跳转到相应标记处 IdeaVim操作 http://kidneyball.iteye.com/blog/1828427 chrome快捷键https://blog.csdn.net/xjz729827161/article/details/78846175 状态略不好，警惕啊 一件事攒着就成梦魇了，一步步分解，不怕解决不掉！！","categories":[{"name":"实用工具","slug":"实用工具","permalink":"https://www.kikfan.com/categories/实用工具/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://www.kikfan.com/tags/IDEA/"},{"name":"快捷键","slug":"快捷键","permalink":"https://www.kikfan.com/tags/快捷键/"},{"name":"浏览器","slug":"浏览器","permalink":"https://www.kikfan.com/tags/浏览器/"}]},{"title":"hexo模板","slug":"hexo模板","date":"2018-11-25T16:02:30.000Z","updated":"2018-12-01T15:49:07.000Z","comments":true,"path":"archives/72c6fac0.html","link":"","permalink":"https://www.kikfan.com/archives/72c6fac0.html","excerpt":"","text":"寻觅有意思的，禁得起研究的东西中…迅速调整，始终保持一颗前行的心，方为根本任时间匆匆流过。。。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.kikfan.com/categories/博客搭建/"}],"tags":[]},{"title":"nginx折腾记","slug":"nginx折腾记","date":"2018-11-23T11:16:12.000Z","updated":"2018-11-24T14:51:14.000Z","comments":true,"path":"archives/c2e234dc.html","link":"","permalink":"https://www.kikfan.com/archives/c2e234dc.html","excerpt":"","text":"docker-compose.yml 12345678910version: '3.1'services: web: image: nginx restart: always container_name: nginx volumes: - ./nginx.conf:/etc/nginx/nginx.conf ports: - \"80:80\" nginx.conf 123456789101112131415161718192021222324252627282930313233user nginx;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # 配置一个代理服务器 upstream kikfan &#123; server space.kikfan.com:5000; &#125; # 配置一个虚拟主机 server &#123; listen 80; server_name yp.kikfan.com; location / &#123; # 域名 yp.kikfan.com 的请求全部转发到 kikfan 服务上 proxy_pass http://kikfan; # 欢迎页面，按照从左到右的顺序查找页面 # index index.jsp index.html index.htm; &#125; &#125;&#125;","categories":[{"name":"好奇尚异","slug":"好奇尚异","permalink":"https://www.kikfan.com/categories/好奇尚异/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://www.kikfan.com/tags/nginx/"},{"name":"折腾","slug":"折腾","permalink":"https://www.kikfan.com/tags/折腾/"}]},{"title":"IDEA插件开发小试牛刀","slug":"IDEA插件开发小试牛刀","date":"2018-11-18T18:01:57.000Z","updated":"2018-11-22T15:18:25.000Z","comments":true,"path":"archives/89d150c.html","link":"","permalink":"https://www.kikfan.com/archives/89d150c.html","excerpt":"","text":"下了个社区版，先试试 Hello World ，后续尝试更多花样12345678910public class HelloAction extends AnAction &#123; @Override public void actionPerformed(AnActionEvent e) &#123; Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String formatDate = sdf.format(date); Messages.showMessageDialog(String.format(\"It is %s now\",formatDate), \"Good Morning\", Messages.getWarningIcon()); &#125;&#125; 心情的起伏人生总是很难一帆风顺，总会磕磕绊绊，所以是否能够不受影响，坚定地去做自己想做的事就显得尤为重要！ 插入时间插件每次写完博客，手动写更新时间真的挺烦，自己动手，丰衣足食 plugin.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;idea-plugin&gt; &lt;id&gt;com.your.company.unique.plugin.id&lt;/id&gt; &lt;name&gt;Insert Time Plugin&lt;/name&gt; &lt;version&gt;1.01&lt;/version&gt; &lt;vendor email=\"gustave.yupeng@gmail.com\" url=\"https://www.kikfan.com\"&gt;Gustave&lt;/vendor&gt; &lt;description&gt;&lt;![CDATA[ 插入当前时间的插件.&lt;br&gt; &lt;em&gt;insert time plugin&lt;/em&gt; ]]&gt;&lt;/description&gt; &lt;change-notes&gt;&lt;![CDATA[ Add change notes here.&lt;br&gt; &lt;em&gt;most HTML tags may be used&lt;/em&gt; ]]&gt; &lt;/change-notes&gt; &lt;!-- please see http://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/build_number_ranges.html for description --&gt; &lt;idea-version since-build=\"173.0\"/&gt; &lt;!-- please see http://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/plugin_compatibility.html on how to target different products --&gt; &lt;!-- uncomment to enable plugin in all products &lt;depends&gt;com.intellij.modules.lang&lt;/depends&gt; --&gt; &lt;extensions defaultExtensionNs=\"com.intellij\"&gt; &lt;!-- Add your extensions here --&gt; &lt;/extensions&gt; &lt;actions&gt; &lt;!-- Add your actions here --&gt; &lt;!--&lt;action id=\"plugins.HelloAction\" class=\"HelloAction\" text=\"HelloAction\" description=\"Say Hello World\"&gt;--&gt; &lt;!--&lt;add-to-group group-id=\"HelpMenu\" anchor=\"after\" relative-to-action=\"About\"/&gt;--&gt; &lt;!--&lt;/action&gt;--&gt; &lt;action id=\"plugins.InsertTimeAction\" class=\"InsertTimeAction\" text=\"InsertTime\" description=\"插入当前时间\"&gt; &lt;add-to-group group-id=\"EditorPopupMenu\" anchor=\"before\" relative-to-action=\"CopyReference\"/&gt; &lt;keyboard-shortcut first-keystroke=\"alt T\" second-keystroke=\"ctrl T\" keymap=\"$default\"/&gt; &lt;/action&gt; &lt;/actions&gt;&lt;/idea-plugin&gt; InsertTimeAction 1234567891011121314151617181920212223242526272829303132333435import com.intellij.openapi.actionSystem.AnAction;import com.intellij.openapi.actionSystem.AnActionEvent;import com.intellij.openapi.actionSystem.PlatformDataKeys;import com.intellij.openapi.command.WriteCommandAction;import com.intellij.openapi.editor.Editor;import com.intellij.openapi.editor.EditorModificationUtil;import com.intellij.openapi.editor.SelectionModel;import org.apache.commons.lang3.StringUtils;import java.text.SimpleDateFormat;import java.util.Date;public class InsertTimeAction extends AnAction &#123; @Override public void actionPerformed(AnActionEvent e) &#123; Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String formatDate = sdf.format(date);// Messages.showMessageDialog(String.format(\"It is %s now\",formatDate), \"Good Morning\", Messages.getWarningIcon()); Editor editor = e.getData(PlatformDataKeys.EDITOR); if (null == editor) &#123; return; &#125; SelectionModel selectionModel = editor.getSelectionModel(); Runnable runnable; if(StringUtils.isBlank(selectionModel.getSelectedText()))&#123; runnable = () -&gt; EditorModificationUtil.insertStringAtCaret(editor, formatDate); &#125; else&#123; runnable = () -&gt;editor.getDocument().replaceString(selectionModel.getSelectionStart(), selectionModel.getSelectionEnd(), formatDate); &#125; WriteCommandAction.runWriteCommandAction(editor.getProject(), runnable); &#125;&#125;","categories":[{"name":"好奇尚异","slug":"好奇尚异","permalink":"https://www.kikfan.com/categories/好奇尚异/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://www.kikfan.com/tags/IDEA/"},{"name":"插件","slug":"插件","permalink":"https://www.kikfan.com/tags/插件/"}]},{"title":"匮乏即是富足，自律产生喜悦","slug":"匮乏即是富足，自律产生喜悦","date":"2018-11-17T11:55:01.000Z","updated":"2018-11-25T14:19:46.000Z","comments":true,"path":"archives/5e60ef9a.html","link":"","permalink":"https://www.kikfan.com/archives/5e60ef9a.html","excerpt":"","text":"（Asceticism and minimalist let a person more sensitive,lack is rich, self-discipline to produce joy! To understand a truth: most people don’t know too much!） ——乔布斯","categories":[{"name":"漫漫人生","slug":"漫漫人生","permalink":"https://www.kikfan.com/categories/漫漫人生/"}],"tags":[{"name":"人生","slug":"人生","permalink":"https://www.kikfan.com/tags/人生/"},{"name":"思考","slug":"思考","permalink":"https://www.kikfan.com/tags/思考/"}]},{"title":"晴雨表","slug":"晴雨表","date":"2018-11-13T13:45:37.000Z","updated":"2019-12-18T19:46:59.000Z","comments":true,"path":"archives/9c72626d.html","link":"","permalink":"https://www.kikfan.com/archives/9c72626d.html","excerpt":"欢迎访问","text":"Welcome, enter password to read this Incorrect Password! No content to display! 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","categories":[{"name":"漫漫人生","slug":"漫漫人生","permalink":"https://www.kikfan.com/categories/漫漫人生/"}],"tags":[{"name":"无聊","slug":"无聊","permalink":"https://www.kikfan.com/tags/无聊/"},{"name":"踌躇徘徊","slug":"踌躇徘徊","permalink":"https://www.kikfan.com/tags/踌躇徘徊/"}]},{"title":"Travis-CI持续集成","slug":"Travis-CI持续集成","date":"2018-11-09T17:20:34.000Z","updated":"2018-11-10T17:20:34.000Z","comments":true,"path":"archives/d4ce3f58.html","link":"","permalink":"https://www.kikfan.com/archives/d4ce3f58.html","excerpt":"生命不息，折腾不止 还是没忍住捣腾了下Travis CI的持续集成，一开始因为墙的问题，node-sass下不来，折腾挺久，坑啊！！ 解决办法就是cnpm！！ 持续集成Coding和Github","text":"生命不息，折腾不止 还是没忍住捣腾了下Travis CI的持续集成，一开始因为墙的问题，node-sass下不来，折腾挺久，坑啊！！ 解决办法就是cnpm！！ 持续集成Coding和Github .travis.yml的配置文件如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869language: node_jsnode_js: stablecache: directories: - node_modules # 缓存不经常更改的内容before_install: - export TZ='Asia/Shanghai' # 更改时区# S: Build Lifecycleinstall: - npm install cnpm -g --registry=https://registry.npm.taobao.org - cnpm install#before_script:# - npm install -g gulpscript: - hexo clean #清除 - hexo g &amp;&amp; gulp #生成after_script: - git clone https://$&#123;GH_REF&#125; .github_git # GH_REF是下面配置的GitHub仓库地址 - cd .github_git - git checkout master - cd ../ - mv .github_git/.git/ ./public/ # 这一步之前的操作是为了保留master分支的提交记录，不然每次git init的话只有1条commit - cd ./public# - git init - git config user.name \"Gustave\" - git config user.email \"1014016816@qq.com\" - git add . - git commit -m \"Travis CI Auto Builder For Github Pages at `date +\"%Y-%m-%d %H:%M\"`\" # 提交记录包含时间 跟上面更改时区配合 # GitHub - git push --force --quiet \"https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;\" master:master - rm -fr .git/ - cd ../ - git clone https://$&#123;CO_REF&#125; .coding_git # CO_REF是最下面配置Coding的仓库地址 - cd .coding_git - git checkout master - cd ../ - mv .coding_git/.git/ ./public/ # 这一步之前的操作是为了保留master分支的提交记录，不然每次git init的话只有1条commit - cd ./public - git config user.name \"Gustave\" - git config user.email \"1014016816@qq.com\" - git add . - git commit -m \"Travis CI Auto Builder For Coding Pages at `date +\"%Y-%m-%d %H:%M\"`\" # 提交记录包含时间 跟上面更改时区配合 # Coding Pages - git push --force --quiet \"https://kikfan:$&#123;CO_TOKEN&#125;@$&#123;CO_REF&#125;\" master:master# E: Build LifeCyclebranches: only: - sourceenv: global: - GH_REF: github.com/kikyou93/kikyou93.github.io.git - CO_REF: git.coding.net/kikfan/kikfan.coding.me.git# configure notifications (email, IRC, campfire etc)# please update this section to your needs!# https://docs.travis-ci.com/user/notifications/notifications: email: - 1014016816@qq.com on_success: change on_failure: always 持续集成了就是方便，哈哈 添加Coding Pages试试 百度爬虫啊，心累! Git commit的问题也是心累 全都保留提交记录，舒服！！ Bingo,问题都铲除了就是爽 hexo g -d呢,摸不着头脑 双十一买什么,头疼 手机编辑试试 添加了时间,还是挺舒服的 摊上单词真是倒了八辈子血霉了 日常推一推,(^_^)","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.kikfan.com/categories/博客搭建/"}],"tags":[{"name":"Travis CI","slug":"Travis-CI","permalink":"https://www.kikfan.com/tags/Travis-CI/"},{"name":"持续集成","slug":"持续集成","permalink":"https://www.kikfan.com/tags/持续集成/"}]},{"title":"感谢IG","slug":"感谢IG","date":"2018-11-03T11:46:19.000Z","updated":"2018-11-04T11:46:19.000Z","comments":true,"path":"archives/a6ddf20d.html","link":"","permalink":"https://www.kikfan.com/archives/a6ddf20d.html","excerpt":"","text":"七年，终于等到了恕我贫瘠的文字没有办法描述我此刻的心情，但作为一个玩lol的老男人，身处网吧，听到此起彼伏的嚎叫的时候，很感慨，有太多的人，等这一刻太久了。","categories":[{"name":"风轻云淡","slug":"风轻云淡","permalink":"https://www.kikfan.com/categories/风轻云淡/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"https://www.kikfan.com/tags/游戏/"}]},{"title":"EasyUI_Tree","slug":"EasyUI-Tree","date":"2018-10-28T16:49:59.000Z","updated":"2018-10-28T16:58:55.000Z","comments":true,"path":"archives/5d3df5f4.html","link":"","permalink":"https://www.kikfan.com/archives/5d3df5f4.html","excerpt":"EasyUi Tree 树的初始化，以及数据格式","text":"EasyUi Tree 树的初始化，以及数据格式 树的数据格式 id：节点的 id，它对于加载远程数据很重要。 text：要显示的节点文本。 state：节点状态，’open’ 或 ‘closed’，默认是 ‘open’。当设置为 ‘closed’ 时，该节点有子节点，并且将从远程站点加载它们。 checked：指示节点是否被选中。 attributes：给一个节点添加的自定义属性。 children：定义了一些子节点的节点数组。 123456789101112131415161718192021222324252627282930313233[&#123; \"id\":1, \"text\":\"Folder1\", \"iconCls\":\"icon-save\", \"children\":[&#123; \"text\":\"File1\", \"checked\":true &#125;,&#123; \"text\":\"Books\", \"state\":\"open\", \"attributes\":&#123; \"url\":\"/demo/book/abc\", \"price\":100 &#125;, \"children\":[&#123; \"text\":\"PhotoShop\", \"checked\":true &#125;,&#123; \"id\": 8, \"text\":\"Sub Bookds\", \"state\":\"closed\" &#125;] &#125;]&#125;,&#123; \"text\":\"Languages\", \"state\":\"closed\", \"children\":[&#123; \"text\":\"Java\" &#125;,&#123; \"text\":\"C#\" &#125;]&#125;] 初始化树 12345678910111213$(\".tt\").tree(&#123; data: treeData, onClick: function (node) &#123; var parentTd = $(this).parents('.ttDiv').parent(); &#125;, onSelect: function (node) &#123; $(this).tree(node.state === 'closed' ? 'expand' : 'collapse', node.target); &#125;, onLoadSuccess: function () &#123; $(this).tree(\"collapseAll\"); &#125;&#125;);","categories":[{"name":"天涯海角","slug":"天涯海角","permalink":"https://www.kikfan.com/categories/天涯海角/"}],"tags":[{"name":"easyUI","slug":"easyUI","permalink":"https://www.kikfan.com/tags/easyUI/"},{"name":"tree","slug":"tree","permalink":"https://www.kikfan.com/tags/tree/"},{"name":"前端","slug":"前端","permalink":"https://www.kikfan.com/tags/前端/"}]},{"title":"Servlet工具类","slug":"Servlet工具类","date":"2018-10-22T14:37:55.000Z","updated":"2018-10-22T14:37:55.000Z","comments":true,"path":"archives/951131f0.html","link":"","permalink":"https://www.kikfan.com/archives/951131f0.html","excerpt":"HttpServletUtils","text":"HttpServletUtils 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import org.apache.commons.lang3.StringUtils;import javax.servlet.http.HttpServletRequest;import java.util.Iterator;import java.util.Map;import java.util.Set;/** * @Author: Gustave * @Date: 2018/8/9 17:47 * @Description: */public class HttpServletUtils &#123; /** * 获取完整请求路径，带请求参数 * * @param request * @return */ public static String getFullPath(HttpServletRequest request) &#123; StringBuffer uri = request.getRequestURL(); String url = uri.toString(); // 获取所有请求,返回 Map 集合 Map&lt;String, String[]&gt; map = request.getParameterMap(); Set&lt;Map.Entry&lt;String, String[]&gt;&gt; entry = map.entrySet(); Iterator&lt;Map.Entry&lt;String, String[]&gt;&gt; iterator = entry.iterator(); // 遍历集合 StringBuffer sb = new StringBuffer(); while (iterator.hasNext()) &#123; Map.Entry&lt;String, String[]&gt; item = iterator.next(); //请求名 String key = item.getKey(); //请求值 for (String value : item.getValue()) &#123; // 拼接每个请求参数 key=value&amp; sb.append(key + \"=\" + value + \"&amp;\"); &#125; &#125; String string = sb.toString(); // 拼接 URL, URL?key=value&amp;key=value&amp; 并且去掉最后一个 &amp; if(StringUtils.isNotBlank(string))&#123; url = url + \"?\" + string.substring(0, string.lastIndexOf(\"&amp;\")); &#125; return url; &#125;&#125;","categories":[{"name":"实用工具","slug":"实用工具","permalink":"https://www.kikfan.com/categories/实用工具/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.kikfan.com/tags/Java/"},{"name":"Servlet","slug":"Servlet","permalink":"https://www.kikfan.com/tags/Servlet/"}]},{"title":"Cookie工具类","slug":"Cookie工具类","date":"2018-10-22T14:34:05.000Z","updated":"2018-10-22T14:34:05.000Z","comments":true,"path":"archives/b1e39e23.html","link":"","permalink":"https://www.kikfan.com/archives/b1e39e23.html","excerpt":"CookieUtils","text":"CookieUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.UnsupportedEncodingException;import java.net.URLDecoder;import java.net.URLEncoder;/** * @Author: Gustave * @Description: */public class CookieUtils &#123; /** * 得到Cookie的值, 不编码 * * @param request * @param cookieName * @return */ public static String getCookieValue(HttpServletRequest request, String cookieName) &#123; return getCookieValue(request, cookieName, false); &#125; /** * 得到Cookie的值, * * @param request * @param cookieName * @return */ public static String getCookieValue(HttpServletRequest request, String cookieName, boolean isDecoder) &#123; Cookie[] cookieList = request.getCookies(); if (cookieList == null || cookieName == null) &#123; return null; &#125; String retValue = null; try &#123; for (int i = 0; i &lt; cookieList.length; i++) &#123; if (cookieList[i].getName().equals(cookieName)) &#123; if (isDecoder) &#123; retValue = URLDecoder.decode(cookieList[i].getValue(), \"UTF-8\"); &#125; else &#123; retValue = cookieList[i].getValue(); &#125; break; &#125; &#125; &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return retValue; &#125; /** * 得到Cookie的值, * * @param request * @param cookieName * @return */ public static String getCookieValue(HttpServletRequest request, String cookieName, String encodeString) &#123; Cookie[] cookieList = request.getCookies(); if (cookieList == null || cookieName == null) &#123; return null; &#125; String retValue = null; try &#123; for (int i = 0; i &lt; cookieList.length; i++) &#123; if (cookieList[i].getName().equals(cookieName)) &#123; retValue = URLDecoder.decode(cookieList[i].getValue(), encodeString); break; &#125; &#125; &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return retValue; &#125; /** * 设置Cookie的值 不设置生效时间默认浏览器关闭即失效,也不编码 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue) &#123; setCookie(request, response, cookieName, cookieValue, -1); &#125; /** * 设置Cookie的值 在指定时间内生效,但不编码 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage) &#123; setCookie(request, response, cookieName, cookieValue, cookieMaxage, false); &#125; /** * 设置Cookie的值 不设置生效时间,但编码 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, boolean isEncode) &#123; setCookie(request, response, cookieName, cookieValue, -1, isEncode); &#125; /** * 设置Cookie的值 在指定时间内生效, 编码参数 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, boolean isEncode) &#123; doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, isEncode); &#125; /** * 设置Cookie的值 在指定时间内生效, 编码参数(指定编码) */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, String encodeString) &#123; doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, encodeString); &#125; /** * 删除Cookie带cookie域名 */ public static void deleteCookie(HttpServletRequest request, HttpServletResponse response, String cookieName) &#123; doSetCookie(request, response, cookieName, \"\", -1, false); &#125; /** * 设置Cookie的值，并使其在指定时间内生效 * * @param cookieMaxage cookie生效的最大秒数 */ private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, boolean isEncode) &#123; try &#123; if (cookieValue == null) &#123; cookieValue = \"\"; &#125; else if (isEncode) &#123; cookieValue = URLEncoder.encode(cookieValue, \"utf-8\"); &#125; Cookie cookie = new Cookie(cookieName, cookieValue); if (cookieMaxage &gt; 0) cookie.setMaxAge(cookieMaxage); if (null != request) &#123;// 设置域名的cookie String domainName = getDomainName(request);// System.out.println(domainName); if (!\"localhost\".equals(domainName)) &#123; cookie.setDomain(domainName); &#125; &#125; cookie.setPath(\"/\"); response.addCookie(cookie); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 设置Cookie的值，并使其在指定时间内生效 * * @param cookieMaxage cookie生效的最大秒数 */ private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, String encodeString) &#123; try &#123; if (cookieValue == null) &#123; cookieValue = \"\"; &#125; else &#123; cookieValue = URLEncoder.encode(cookieValue, encodeString); &#125; Cookie cookie = new Cookie(cookieName, cookieValue); if (cookieMaxage &gt; 0) cookie.setMaxAge(cookieMaxage); if (null != request) &#123;// 设置域名的cookie String domainName = getDomainName(request);// System.out.println(domainName); if (!\"localhost\".equals(domainName)) &#123; cookie.setDomain(domainName); &#125; &#125; cookie.setPath(\"/\"); response.addCookie(cookie); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 得到cookie的域名 */ private static final String getDomainName(HttpServletRequest request) &#123; String domainName = null; String serverName = request.getRequestURL().toString(); if (serverName == null || serverName.equals(\"\")) &#123; domainName = \"\"; &#125; else &#123; serverName = serverName.toLowerCase(); serverName = serverName.substring(7); final int end = serverName.indexOf(\"/\"); serverName = serverName.substring(0, end); final String[] domains = serverName.split(\"\\\\.\"); int len = domains.length; if (len &gt; 3) &#123; // www.xxx.com.cn domainName = \".\" + domains[len - 3] + \".\" + domains[len - 2] + \".\" + domains[len - 1]; &#125; else if (len &lt;= 3 &amp;&amp; len &gt; 1) &#123; // xxx.com or xxx.cn domainName = \".\" + domains[len - 2] + \".\" + domains[len - 1]; &#125; else &#123; domainName = serverName; &#125; &#125; if (domainName != null &amp;&amp; domainName.indexOf(\":\") &gt; 0) &#123; String[] ary = domainName.split(\"\\\\:\"); domainName = ary[0]; &#125; return domainName; &#125;&#125;","categories":[{"name":"实用工具","slug":"实用工具","permalink":"https://www.kikfan.com/categories/实用工具/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.kikfan.com/tags/Java/"},{"name":"Cookie","slug":"Cookie","permalink":"https://www.kikfan.com/tags/Cookie/"}]},{"title":"Jackson工具类","slug":"Jackson工具类","date":"2018-10-22T14:28:54.000Z","updated":"2018-10-22T14:28:54.000Z","comments":true,"path":"archives/80084445.html","link":"","permalink":"https://www.kikfan.com/archives/80084445.html","excerpt":"MapperUtils","text":"MapperUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211/** * @Author: Gustave * @Description: */public class MapperUtils &#123; private final static ObjectMapper objectMapper = new ObjectMapper(); public static ObjectMapper getInstance() &#123; return objectMapper; &#125; /** * 转换为 JSON 字符串 * * @param obj * @return * @throws Exception */ public static String obj2json(Object obj) throws Exception &#123; return objectMapper.writeValueAsString(obj); &#125; /** * 转换为 JSON 字符串，忽略空值 * * @param obj * @return * @throws Exception */ public static String obj2jsonIgnoreNull(Object obj) throws Exception &#123; ObjectMapper mapper = new ObjectMapper(); mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); return mapper.writeValueAsString(obj); &#125; /** * 转换为 JavaBean * * @param jsonString * @param clazz * @return * @throws Exception */ public static &lt;T&gt; T json2pojo(String jsonString, Class&lt;T&gt; clazz) throws Exception &#123; objectMapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true); return objectMapper.readValue(jsonString, clazz); &#125; /** * 字符串转换为 Map&lt;String, Object&gt; * * @param jsonString * @return * @throws Exception */ public static &lt;T&gt; Map&lt;String, Object&gt; json2map(String jsonString) throws Exception &#123; ObjectMapper mapper = new ObjectMapper(); mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); return mapper.readValue(jsonString, Map.class); &#125; /** * 字符串转换为 Map&lt;String, T&gt; */ public static &lt;T&gt; Map&lt;String, T&gt; json2map(String jsonString, Class&lt;T&gt; clazz) throws Exception &#123; Map&lt;String, Map&lt;String, Object&gt;&gt; map = objectMapper.readValue(jsonString, new TypeReference&lt;Map&lt;String, T&gt;&gt;() &#123; &#125;); Map&lt;String, T&gt; result = new HashMap&lt;String, T&gt;(); for (Map.Entry&lt;String, Map&lt;String, Object&gt;&gt; entry : map.entrySet()) &#123; result.put(entry.getKey(), map2pojo(entry.getValue(), clazz)); &#125; return result; &#125; /** * 深度转换 JSON 成 Map * * @param json * @return */ public static Map&lt;String, Object&gt; json2mapDeeply(String json) throws Exception &#123; return json2MapRecursion(json, objectMapper); &#125; /** * 把 JSON 解析成 List，如果 List 内部的元素存在 jsonString，继续解析 * * @param json * @param mapper 解析工具 * @return * @throws Exception */ private static List&lt;Object&gt; json2ListRecursion(String json, ObjectMapper mapper) throws Exception &#123; if (json == null) &#123; return null; &#125; List&lt;Object&gt; list = mapper.readValue(json, List.class); for (Object obj : list) &#123; if (obj != null &amp;&amp; obj instanceof String) &#123; String str = (String) obj; if (str.startsWith(\"[\")) &#123; obj = json2ListRecursion(str, mapper); &#125; else if (obj.toString().startsWith(\"&#123;\")) &#123; obj = json2MapRecursion(str, mapper); &#125; &#125; &#125; return list; &#125; /** * 把 JSON 解析成 Map，如果 Map 内部的 Value 存在 jsonString，继续解析 * * @param json * @param mapper * @return * @throws Exception */ private static Map&lt;String, Object&gt; json2MapRecursion(String json, ObjectMapper mapper) throws Exception &#123; if (json == null) &#123; return null; &#125; Map&lt;String, Object&gt; map = mapper.readValue(json, Map.class); for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123; Object obj = entry.getValue(); if (obj != null &amp;&amp; obj instanceof String) &#123; String str = ((String) obj); if (str.startsWith(\"[\")) &#123; List&lt;?&gt; list = json2ListRecursion(str, mapper); map.put(entry.getKey(), list); &#125; else if (str.startsWith(\"&#123;\")) &#123; Map&lt;String, Object&gt; mapRecursion = json2MapRecursion(str, mapper); map.put(entry.getKey(), mapRecursion); &#125; &#125; &#125; return map; &#125; /** * 将 JSON 数组转换为集合 * * @param jsonArrayStr * @param clazz * @return * @throws Exception */ public static &lt;T&gt; List&lt;T&gt; json2list(String jsonArrayStr, Class&lt;T&gt; clazz) throws Exception &#123; JavaType javaType = getCollectionType(ArrayList.class, clazz); List&lt;T&gt; list = (List&lt;T&gt;) objectMapper.readValue(jsonArrayStr, javaType); return list; &#125; /** * 获取泛型的 Collection Type * * @param collectionClass 泛型的Collection * @param elementClasses 元素类 * @return JavaType Java类型 * @since 1.0 */ public static JavaType getCollectionType(Class&lt;?&gt; collectionClass, Class&lt;?&gt;... elementClasses) &#123; return objectMapper.getTypeFactory().constructParametricType(collectionClass, elementClasses); &#125; /** * 将 Map 转换为 JavaBean * * @param map * @param clazz * @return */ public static &lt;T&gt; T map2pojo(Map map, Class&lt;T&gt; clazz) &#123; return objectMapper.convertValue(map, clazz); &#125; /** * 将 Map 转换为 JSON * * @param map * @return */ public static String mapToJson(Map map) &#123; try &#123; return objectMapper.writeValueAsString(map); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return \"\"; &#125; /** * 将 JSON 对象转换为 JavaBean * * @param obj * @param clazz * @return */ public static &lt;T&gt; T obj2pojo(Object obj, Class&lt;T&gt; clazz) &#123; return objectMapper.convertValue(obj, clazz); &#125;&#125;","categories":[{"name":"实用工具","slug":"实用工具","permalink":"https://www.kikfan.com/categories/实用工具/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.kikfan.com/tags/Java/"},{"name":"Jackson","slug":"Jackson","permalink":"https://www.kikfan.com/tags/Jackson/"}]},{"title":"关于RNG,关于LOL","slug":"关于RNG-关于LOL","date":"2018-10-20T17:51:33.000Z","updated":"2018-10-20T17:51:33.000Z","comments":true,"path":"archives/587eb1e3.html","link":"","permalink":"https://www.kikfan.com/archives/587eb1e3.html","excerpt":"","text":"游戏而已RNG输了，输的很彻底，输的很难看。对于脱坑很久的老咸鱼来说，看比赛这唯一的乐趣也再也提不起来了。或许是我一向的低预期习惯，比赛前就隐隐感觉不会那么轻松，结果就真的发生了。。。希望IG可以努努力，不要太伤老玩家的心吧","categories":[{"name":"风轻云淡","slug":"风轻云淡","permalink":"https://www.kikfan.com/categories/风轻云淡/"}],"tags":[{"name":"游戏人生","slug":"游戏人生","permalink":"https://www.kikfan.com/tags/游戏人生/"}]},{"title":"龟兔赛跑","slug":"龟兔赛跑","date":"2018-10-13T21:40:09.000Z","updated":"2019-11-19T03:12:51.000Z","comments":true,"path":"archives/20450659.html","link":"","permalink":"https://www.kikfan.com/archives/20450659.html","excerpt":"欢迎访问","text":"Welcome, enter password to read this Incorrect Password! No content to display! U2FsdGVkX1/Q29f2ZjS1TZdt0JnEzWFN/D5w7QA46q+BI7I03ffl9ovxUw8UhsbrLnMOKx/C/2R5wOjgMXI7CPC3KZhhez6AREbS55P4m2Onezaf9CZsxK9/A6XW4loZl2U/Huvkc5+C4bnolHBL2UVJWkAB7W8Y53rRw6sLWyy9b0XAxHLmfCKbzXrmKG7AF+aBO9apmpvdFwlXqKlVVkihTAljPrVTQMcO2T7v/x+5tp1bp7RYeSbmuzpMk80IBnMb7ADPbkJU2Pf9ygLuBZ14rHdLKRPtot4sD5TesZywIhq38qqKJUZiXsOjWkSTGW4vfY0k3ciA/NA9ZEQu7+MFG4Rr8P98UABjmG4vLXz03+3f1elHp6H5aF8zvzaPJibwmbgD+k1FzQ/w1xjnqJ4IiPQaSukhd8RnxufU4WZVyxbHDN9s5QtvU9vVqVHen3quyFKRYgRKBiTiOKDBJT9u78xLGF8XudENlQks9H2NeR9mO9+0DlQG2M6/3Y4b8Zv88CM7RQvBtZU1N8ILJ5Xd1oksrF0x4cjBIAq8BCAuf7mBK9hbGNDgB+6x9XEj/ilR5T9ht/N/PR0ESNtGdZEMMc2SnYl0yyHOMSKTRekDhIXwQH97fqvdd9uTL2D9PWpcbINsGxiAQSv4Umf3GQVryoVc+ApzMArjUDulXb5t3llEmgZhCBIhI26rdRaGwBOWZ2Oen9+lTByGMeuAofKZSz/chMZCOZYdiJFesvvj0rGunJX1eEDliwJwxvygm0znw3GvlL5oUhQ+VTFGuDZOgImiQhDIO5ElNu6qwxgB9f/TOfsnb8UgE8PCrLDTnAEaJETXHJ+Bq8ZnJvVEwVu5Te3/W+OL54VqKCaM/+8p7ci2DDhiNmBWBfzzGhziGFLDmwVoiFEiSa3Nlgjg2rf8OObyW7nbPx8gdTW078pep1kHmIpliGnnDKHIsQ5R","categories":[{"name":"漫漫人生","slug":"漫漫人生","permalink":"https://www.kikfan.com/categories/漫漫人生/"}],"tags":[{"name":"人生思考","slug":"人生思考","permalink":"https://www.kikfan.com/tags/人生思考/"}]},{"title":"Hello Hexo","slug":"hello-hexo","date":"2018-10-10T17:30:09.000Z","updated":"2018-10-10T17:30:09.000Z","comments":true,"path":"archives/a1751c09.html","link":"","permalink":"https://www.kikfan.com/archives/a1751c09.html","excerpt":"Welcome to Hexo!","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment hexo 模板写法","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.kikfan.com/categories/博客搭建/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://www.kikfan.com/tags/blog/"},{"name":"seo","slug":"seo","permalink":"https://www.kikfan.com/tags/seo/"}]}]}