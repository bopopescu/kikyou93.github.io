---
title: 一叶障目，不见泰山
tags: [SQL,Java]
date: 2019-02-27 00:01:48
updated: 2019-03-05 02:15:35
categories: SQL
---

- 过于草率地相信直觉的判断了，作为一个猜想是需要验证的，想当然才是根源
- 执行力不够，脑袋里产生想法之后一定要立即马上去验证，时间长了就忘了！！（最次也得上备忘录）
- 对于连表的理解有欠缺
- sql语句多学多看，多查，终身学习，不要被其他的边边角角占据了头脑，保持敏锐！


# Update Join / Delete Join
```sql
update table_name_1
inner join table_name_2 on table_name_1.id = table_name_2.uid
inner join table_name_3 on table_name_3.id = table_name_1.tid
set *** = ***
where ***
```
- 说多了都是泪啊

# 获取表中某字段包含某字符串的数据
```sql
SELECT * FROM `表名` WHERE LOCATE('关键字', 字段名)
```
- locate函数的用法

# 连续范围的问题
```sql
# 创建测试表
CREATE TABLE `test_number` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `number` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '数字',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;


# 创建测试数据
insert into test_number values(1,1);
insert into test_number values(2,2);
insert into test_number values(3,3);
insert into test_number values(4,5);
insert into test_number values(5,7);
insert into test_number values(6,8);
insert into test_number values(7,10);
insert into test_number values(8,11);

SELECT min(number) start_range, max(number) end_range
FROM (SELECT number, rn, number - rn diff
      FROM (SELECT number, @number := @number + 1 rn
            FROM test_number,
                 (SELECT @number := 0) AS number) b) c
GROUP BY diff;
```

# 签到问题
```sql
# 创建参考表(模拟数据需要用到)
CREATE TABLE `test_nums` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='参考表';
# 模拟数据，插入 1-1000 连续数据.
create PROCEDURE test()
  BEGIN
    DECLARE i int DEFAULT 1;
    WHILE (i < 1000) DO INSERT INTO test_nums VALUES (i);
      SET i = i + 1;
    END WHILE;
  END;
CALL test();
DROP PROCEDURE test;

# 创建测试表
CREATE TABLE `test_sign_history` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `uid` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '用户ID',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '签到时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='签到历史表';

# 创建测试数据
insert into test_sign_history(uid,create_time)
select ceil(rand()*10000),str_to_date('2016-12-11','%Y-%m-%d')+interval ceil(rand()*10000) minute
from test_nums where id<500;

# 统计每天的每小时用户签到情况
SELECT
       tmp.h,
       sum(CASE WHEN tmp.d = '20161211' THEN tmp.c ELSE 0 END ) as 11sign,
       sum(CASE WHEN tmp.d = '20161212' THEN tmp.c ELSE 0 END ) as 12sign,
       sum(CASE WHEN tmp.d = '20161213' THEN tmp.c ELSE 0 END ) as 13sign,
       sum(CASE WHEN tmp.d = '20161214' THEN tmp.c ELSE 0 END ) as 14sign,
       sum(CASE WHEN tmp.d = '20161215' THEN tmp.c ELSE 0 END ) as 15sign,
       sum(CASE WHEN tmp.d = '20161216' THEN tmp.c ELSE 0 END ) as 16sign,
       sum(CASE WHEN tmp.d = '20161217' THEN tmp.c ELSE 0 END ) as 17sign
FROM
(select hour(create_time) h,date_format(create_time,'%Y%m%d') as d,count(*) c
FROM test_sign_history group BY h,d) tmp
GROUP BY tmp.h ORDER BY tmp.h;

# 统计每天的每小时用户签到情况(当某个小时没有数据时，显示0)
# 主要在于使用了辅助表，使用它用来作为left join 的主表
SELECT
       tmp.h,
       sum(CASE WHEN tmp.d = '20161211' THEN tmp.c ELSE 0 END ) as 11sign,
       sum(CASE WHEN tmp.d = '20161212' THEN tmp.c ELSE 0 END ) as 12sign,
       sum(CASE WHEN tmp.d = '20161213' THEN tmp.c ELSE 0 END ) as 13sign,
       sum(CASE WHEN tmp.d = '20161214' THEN tmp.c ELSE 0 END ) as 14sign,
       sum(CASE WHEN tmp.d = '20161215' THEN tmp.c ELSE 0 END ) as 15sign,
       sum(CASE WHEN tmp.d = '20161216' THEN tmp.c ELSE 0 END ) as 16sign,
       sum(CASE WHEN tmp.d = '20161217' THEN tmp.c ELSE 0 END ) as 17sign
FROM
     (SELECT b.h,tsh.d,tsh.c
     FROM (SELECT id as h FROM test_nums WHERE id <= 24) b
     LEFT JOIN
     (select hour(create_time) h,date_format(create_time,'%Y%m%d') as d,count(*) c
      FROM test_sign_history group BY h,d) tsh ON b.h = tsh.h
     ) tmp
GROUP BY tmp.h ORDER BY tmp.h;

# 统计每天的用户签到数据和每天的增量数据
# 自己想的写法
SELECT t.d, t.cnt, t.cnt - @rown AS increase, @rown := t.cnt
FROM (SELECT date_format(create_time, '%Y%m%d') AS d, count(*) AS cnt
            FROM test_sign_history
      GROUP BY d
      ORDER BY d) t,
     (SELECT @rown := 0) r;


# 参考写法
# 两种写法，思想不同而已
SELECT type,
       sum(CASE WHEN create_time = '2016-12-11' THEN c ELSE 0 END) 11Sign,
       sum(CASE WHEN create_time = '2016-12-12' THEN c ELSE 0 END) 12Sign,
       sum(CASE WHEN create_time = '2016-12-13' THEN c ELSE 0 END) 13Sign,
       sum(CASE WHEN create_time = '2016-12-14' THEN c ELSE 0 END) 14Sign,
       sum(CASE WHEN create_time = '2016-12-15' THEN c ELSE 0 END) 15Sign,
       sum(CASE WHEN create_time = '2016-12-16' THEN c ELSE 0 END) 16Sign,
       sum(CASE WHEN create_time = '2016-12-17' THEN c ELSE 0 END) 17Sign
FROM (SELECT b.create_time, ifnull(b.c - c.c, 0) c, 'Increment' type
      FROM (SELECT date_format(create_time, '%Y-%m-%d') create_time, count(*) c
            FROM test_sign_history
            GROUP BY date_format(create_time, '%Y-%m-%d')) b
             LEFT JOIN (SELECT date_format(create_time, '%Y-%m-%d') create_time, count(*) c
                        FROM test_sign_history
                        GROUP BY date_format(create_time, '%Y-%m-%d')) c
               ON (b.create_time = c.create_time + INTERVAL 1 DAY)
      UNION ALL
      SELECT date_format(create_time, '%Y-%m-%d') create_time, count(*) c, 'Current'
      FROM test_sign_history
      GROUP BY date_format(create_time, '%Y-%m-%d')) a
GROUP BY type
ORDER BY CASE WHEN type = 'Current' THEN 1 ELSE 0 END DESC;


#模拟不同的用户签到了不同的天数
insert into test_sign_history(uid,create_time)
select uid,create_time + interval ceil(rand()*10) day from test_sign_history,test_nums
where test_nums.id <10 order by rand() limit 150;

# 统计签到天数相同的用户数量
SELECT date_format(create_time,'%Y%m%d') as d,count(DISTINCT uid) AS user_cnt
FROM test_sign_history GROUP BY d ORDER BY d;

# 统计每个用户的连续签到时间
# 属于连续问题的解决办法
SELECT tmp2.uid,max(tmp2.sign_last) FROM
       (
       SELECT tmp.uid, min(d) AS begin_date, max(d) AS end_date, datediff(max(d), min(d)) + 1 AS sign_last
        FROM (SELECT ud.uid, ud.d, datediff(ud.d, @time) AS diff, @time := @time + INTERVAL 1 DAY
              FROM (SELECT uid, date_format(create_time, '%Y-%m-%d') AS d
                    FROM test_sign_history
                    GROUP BY uid, d
                    ORDER BY uid, d) ud,
                   (SELECT @time := '2016-01-01') t) tmp
        GROUP BY tmp.uid, tmp.diff
       ) tmp2 GROUP BY tmp2.uid;

# 参考写法
SELECT *
FROM (SELECT d.*, @ggid := @cggid, @cggid := d.uid, if(@ggid = @cggid, @grank := @grank + 1, @grank := 1) grank
      FROM (SELECT uid, min(c.create_time) begin_date, max(c.create_time) end_date, count(*) count
            FROM (SELECT b.*,
                         @gid := @cgid,
                         @cgid := b.uid,
                         if(@gid = @cgid, @rank := @rank + 1, @rank := 1),
                         b.diff - @rank as flag
                  FROM (SELECT DISTINCT uid,
                                        date_format(create_time, '%Y-%m-%d') create_time,
                                        datediff(create_time, now())         diff
                        FROM test_sign_history
                        ORDER BY uid, create_time) b,
                       (SELECT @gid := 1, @cgid := 1, @rank := 1) AS a) c
            GROUP BY uid, flag
            ORDER BY uid, count(*) DESC) d,
           (SELECT @ggid := 1, @cggid := 1, @grank := 1) AS e)f
WHERE grank = 1;

```

[MySQL2](https://blog.csdn.net/Thomson617/article/details/83140926)

# MySQL的测试表
```sql
create table if not exists student(
  s_id varchar (20),
  s_name varchar (20) not null default '',
  s_birth varchar (20)not null default '',
  s_sex varchar (10) not null default '',
  primary key (s_id)
) ;

create table course(
  c_id varchar (20),
  c_name varchar (20)not null default '',
  t_id varchar (20)not null default '',
  primary key( c_id)
);

create table teacher(
  t_id varchar (20),
  t_name varchar (20)not null default '',
  primary key (t_id)
);

create table score(
  s_id varchar (20),
  c_id varchar (20),
  s_score int(3),
  primary key (s_id,c_id)
);

insert into Student values('01' , '赵雷' , '1990-01-01' , '男');
insert into Student values('02' , '钱电' , '1990-12-21' , '男');
insert into Student values('03' , '孙风' , '1990-05-20' , '男');
insert into Student values('04' , '李云' , '1990-08-06' , '男');
insert into Student values('05' , '周梅' , '1991-12-01' , '女');
insert into Student values('06' , '吴兰' , '1992-03-01' , '女');
insert into Student values('07' , '郑竹' , '1989-07-01' , '女');
insert into Student values('08' , '王菊' , '1990-01-20' , '女');

insert into Course values('01' , '语文' , '02');
insert into Course values('02' , '数学' , '01');
insert into Course values('03' , '英语' , '03');

insert into Teacher values('01' , '张三');
insert into Teacher values('02' , '李四');
insert into Teacher values('03' , '王五');

insert into Score values('01' , '01' , 80);
insert into Score values('01' , '02' , 90);
insert into Score values('01' , '03' , 99);
insert into Score values('02' , '01' , 70);
insert into Score values('02' , '02' , 60);
insert into Score values('02' , '03' , 80);
insert into Score values('03' , '01' , 80);
insert into Score values('03' , '02' , 80);
insert into Score values('03' , '03' , 80);
insert into Score values('04' , '01' , 50);
insert into Score values('04' , '02' , 30);
insert into Score values('04' , '03' , 20);
insert into Score values('05' , '01' , 76);
insert into Score values('05' , '02' , 87);
insert into Score values('06' , '01' , 31);
insert into Score values('06' , '03' , 34);
insert into Score values('07' , '02' , 89);
insert into Score values('07' , '03' , 98);

```

# 查询"01"课程比"02"课程成绩高的学生的信息及课程分数
- 考虑02课程没选的的情况
SELECT
s.*,sc.s_score AS 01score,sc2.s_score AS 02score
FROM student s INNER JOIN score sc ON s.s_id = sc.s_id AND sc.c_id = '01'
LEFT JOIN score sc2 ON s.s_id = sc2.s_id AND sc2.c_id = '02'
WHERE sc.s_score < sc2.s_score OR sc.s_score is NULL ;

SELECT student.*, a.s_score AS 01_score, b.s_score AS 02_score
FROM student
       JOIN score a ON student.s_id = a.s_id AND a.c_id = '01'
       LEFT JOIN score b ON student.s_id = b.s_id AND b.c_id = '02' OR b.c_id = NULL
WHERE a.s_score > b.s_score;

# 查询"01"课程比"02"课程成绩低的学生的信息及课程分数

SELECT student.*, a.s_score AS 01_score, b.s_score AS 02_score
FROM student
       JOIN score a ON student.s_id = a.s_id AND a.c_id = '01' OR a.c_id = NULL
       LEFT JOIN score b ON student.s_id = b.s_id AND b.c_id = '02'
WHERE a.s_score < b.s_score;

# 查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩

SELECT student.s_id, student.s_name, tmp.avg_score
FROM student
       JOIN (SELECT score.s_id, round(avg(score.s_score), 1)AS avg_score FROM score GROUP BY s_id)AS tmp
         ON tmp.avg_score >= 60
WHERE student.s_id = tmp.s_id;

–答案2

SELECT student.s_id, student.s_name, round(avg(score.s_score), 1) AS avg_score
FROM student
       JOIN score ON student.s_id = score.s_id
GROUP BY score.s_id
HAVING avg(score.s_score) >= 60;

# 查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩
– (包括有成绩的和无成绩的)

SELECT student.s_id, student.s_name, tmp.avg_score
FROM student
       JOIN (SELECT score.s_id, round(avg(score.s_score), 1)AS avg_score FROM score GROUP BY s_id)AS tmp
         ON tmp.avg_score < 60
WHERE student.s_id = tmp.s_id
UNION
SELECT s_id, s_name, 0 AS avg_score
FROM student
WHERE s_id NOT IN
      (SELECT DISTINCT s_id FROM score);

–答案2

SELECT student.s_id, student.s_name, round(avg(score.s_score), 1) AS avg_score
FROM student
       JOIN score ON student.s_id = score.s_id
GROUP BY score.s_id
HAVING avg(score.s_score) < 60
UNION
SELECT s_id, s_name, 0 AS avg_score
FROM student
WHERE s_id NOT IN
      (SELECT DISTINCT s_id FROM score);

# 查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩

SELECT student.s_id, student.s_name, (count(score.c_id))AS total_count, sum(score.s_score)AS total_score
FROM student
       LEFT JOIN score ON student.s_id = score.s_id
GROUP BY score.s_id;

# 查询"李"姓老师的数量

SELECT t_name, count(1)
FROM teacher
WHERE t_name LIKE '李%';

# 查询学过"张三"老师授课的同学的信息

SELECT *
FROM student
       JOIN score ON student.s_id = score.s_id
WHERE score.c_id IN (SELECT course.c_id
                     FROM course
                     WHERE course.t_id IN (SELECT teacher.t_id FROM teacher WHERE teacher.t_name = '张三'));

–答案2

SELECT student.*
FROM student
       JOIN score ON student.s_id = score.s_id
       JOIN course ON course.c_id = score.c_id
       JOIN teacher ON course.t_id = teacher.t_id AND t_name = '张三';

# 查询没学过"张三"老师授课的同学的信息

SELECT *
FROM student
WHERE s_id NOT IN (SELECT score.s_id
                   FROM score
                   WHERE score.c_id IN (SELECT course.c_id
                                        FROM course
                                        WHERE course.t_id =
                                              (SELECT teacher.t_id FROM teacher WHERE teacher.t_name = '张三')));

–答案2

SELECT student.*
FROM student
       LEFT JOIN (SELECT s_id
                  FROM score
                         JOIN course ON course.c_id = score.c_id
                         JOIN teacher ON course.t_id = teacher.t_id AND t_name = '张三')tmp ON student.s_id = tmp.s_id
WHERE tmp.s_id IS NULL;

# 查询学过编号为"01"并且也学过编号为"02"的课程的同学的信息

SELECT *
FROM student
WHERE s_id IN (SELECT s_id FROM score WHERE c_id = 1)
  AND s_id IN (SELECT s_id FROM score WHERE c_id = 2);

# 查询学过编号为"01"但是没有学过编号为"02"的课程的同学的信息

SELECT *
FROM student
WHERE s_id IN (SELECT s_id FROM score WHERE c_id = 1)
  AND s_id NOT IN (SELECT s_id FROM score WHERE c_id = 2);

–答案2

SELECT student.*
FROM student
       JOIN (SELECT s_id FROM score WHERE c_id = 1)tmp1 ON student.s_id = tmp1.s_id
       LEFT JOIN (SELECT s_id FROM score WHERE c_id = 2)tmp2 ON student.s_id = tmp2.s_id
WHERE tmp2.s_id IS NULL;

# 查询没有学全所有课程的同学的信息

SELECT *
FROM student
WHERE s_id IN (SELECT s_id FROM score GROUP BY s_id HAVING count(c_id) = (SELECT count(1) FROM course));

# 查询至少有一门课与学号为"01"的同学所学相同的同学的信息

SELECT *
FROM student
WHERE s_id <> 01
  AND s_id IN (SELECT s_id FROM score WHERE c_id IN (SELECT c_id FROM score WHERE score.s_id = 01) GROUP BY s_id);

# 查询和"01"号的同学学习的课程完全相同的其他同学的信息

SELECT student.*, tmp.course_id
FROM (SELECT s_id, group_concat(c_id) course_id
      FROM score
      GROUP BY s_id
      HAVING s_id <> 1
         AND course_id = (SELECT group_concat(c_id) course_id2 FROM score WHERE s_id = 1))tmp
       JOIN student ON student.s_id = tmp.s_id;

# 查询没学过"张三"老师讲授的任一门课程的学生姓名

SELECT *
FROM student
WHERE s_id NOT IN (SELECT s_id
                   FROM score
                          JOIN (SELECT c_id FROM course WHERE t_id IN (SELECT t_id FROM teacher WHERE t_name = '张三'))tmp
                            ON score.c_id = tmp.c_id);

–答案2

SELECT student.*
FROM student
       LEFT JOIN (SELECT s_id
                  FROM score
                         JOIN (SELECT c_id FROM course
                                                  JOIN teacher ON course.t_id = teacher.t_id AND t_name = '张三')tmp2
                           ON score.c_id = tmp2.c_id)tmp ON student.s_id = tmp.s_id
WHERE tmp.s_id IS NULL;

# 查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩

SELECT student.s_id, student.s_name, tmp.avg_score
FROM student
       LEFT JOIN (SELECT s_id, round(AVG(score.s_score)) avg_score FROM score GROUP BY s_id)tmp
         ON tmp.s_id = student.s_id
WHERE student.s_id IN (SELECT s_id FROM score WHERE s_score < 60 GROUP BY score.s_id HAVING count(s_id) > 1);

# 检索"01"课程分数小于60，按分数降序排列的学生信息

SELECT student.*, s_score
FROM student,
     score
WHERE student.s_id = score.s_id
  AND s_score < 60
  AND c_id = '01'
ORDER BY s_score DESC;

# 按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩

SELECT s_id,
       (SELECT s_score
        FROM score
        WHERE s_id = a.s_id
          AND c_id = '01')AS     '语文',
       (SELECT s_score
        FROM score
        WHERE s_id = a.s_id
          AND c_id = '02')AS     '数学',
       (SELECT s_score
        FROM score
        WHERE s_id = a.s_id
          AND c_id = '03')AS     '英语',
       round(avg(s_score), 2) AS '平均分'
FROM score a
GROUP BY s_id
ORDER BY '平均分' DESC;

–答案2

SELECT a.s_id,
       tmp1.s_score             AS chinese,
       tmp2.s_score             AS math,
       tmp3.s_score             AS english,
       round(avg(a.s_score), 2) AS avgScore
FROM score a
       LEFT JOIN (SELECT s_id, s_score FROM score s1 WHERE c_id = '01')tmp1 ON tmp1.s_id = a.s_id
       LEFT JOIN (SELECT s_id, s_score FROM score s2 WHERE c_id = '02')tmp2 ON tmp2.s_id = a.s_id
       LEFT JOIN (SELECT s_id, s_score FROM score s3 WHERE c_id = '03')tmp3 ON tmp3.s_id = a.s_id
GROUP BY a.s_id, tmp1.s_score, tmp2.s_score, tmp3.s_score
ORDER BY avgScore DESC;

# 查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率 –及格为>=60，中等为：70-80，优良为：80-90，优秀为：>=90

SELECT score.c_id    AS                                                                                     '课程ID',
       course.c_name AS                                                                                     '课程name',
       max(s_score)  AS                                                                                     '最高分',
       min(s_score)AS                                                                                       '最低分',
       round(avg(s_score), 2)                                                                               '平均分',
       round(sum(CASE WHEN s_score >= 60 THEN 1 ELSE 0 END) / sum(CASE WHEN s_score THEN 1 ELSE 0 END), 2)'及格率',
       round(sum(CASE WHEN s_score >= 70 AND s_score < 80 THEN 1 ELSE 0 END) / sum(CASE WHEN s_score THEN 1 ELSE 0 END),
             2)'中等率',
       round(sum(CASE WHEN s_score >= 80 AND s_score < 90 THEN 1 ELSE 0 END) / sum(CASE WHEN s_score THEN 1 ELSE 0 END),
             2)'优良率',
       round(sum(CASE WHEN s_score >= 90 THEN 1 ELSE 0 END) / (SUM(CASE WHEN s_score THEN 1 ELSE 0 END)), 2)'优秀率'
FROM score
       LEFT JOIN course ON score.c_id = course.c_id
GROUP BY score.c_id;

–答案2

SELECT course.c_id,
       course.c_name,
       tmp.maxScore,
       tmp.minScore,
       tmp.avgScore,
       tmp.passRate,
       tmp.moderate,
       tmp.goodRate,
       tmp.excellentRates
FROM course
       JOIN (SELECT c_id,
                    max(s_score) AS                                                                         maxScore,
                    min(s_score)AS                                                                          minScore,
                    round(avg(s_score), 2)                                                                  avgScore,
                    round(sum(CASE WHEN s_score >= 60 THEN 1 ELSE 0 END) / count(c_id), 2)passRate,
                    round(sum(CASE WHEN s_score >= 60 AND s_score < 70 THEN 1 ELSE 0 END) / count(c_id), 2) moderate,
                    round(sum(CASE WHEN s_score >= 70 AND s_score < 80 THEN 1 ELSE 0 END) / count(c_id), 2) goodRate,
                    round(sum(CASE WHEN s_score >= 80 AND s_score < 90 THEN 1 ELSE 0 END) / count(c_id),
                          2)                                                                                excellentRates
             FROM score
             GROUP BY c_id)tmp ON tmp.c_id = course.c_id;
# 按各科成绩进行排序，并显示排名(实现不完全)
– mysql没有rank函数
–方法1

(SELECT * FROM
(SELECT s1.s_id, s1.c_id, s1.s_score,
(SELECT COUNT (DISTINCT sc.s_score) FROM score sc
WHERE sc.s_score>=s1.s_score AND sc.c_id = '01') 'rank不保留排名'
FROM score s1 WHERE s1.c_id = '01' ORDER BY s1.s_score DESC) t1)
UNION (SELECT * FROM
(SELECT s1.s_id, s1.c_id, s1.s_score,
(SELECT COUNT (DISTINCT sc.s_score) FROM score sc
WHERE sc.s_score>=s1.s_score AND sc.c_id = '02') 'rank不保留排名'
FROM score s1 WHERE s1.c_id = '02' ORDER BY s1.s_score DESC) t2)
UNION (SELECT * FROM
(SELECT s1.s_id, s1.c_id, s1.s_score,
(SELECT COUNT (DISTINCT sc.s_score) FROM score sc
WHERE sc.s_score>=s1.s_score AND sc.c_id = '03') 'rank不保留排名'
FROM score s1 WHERE s1.c_id = '03' ORDER BY s1.s_score DESC) t3)

–方法2

(SELECT a.s_id, a.c_id, @i:=@i+1 AS i保留排名,
@k:=(CASE WHEN @score = a.s_score THEN @k ELSE @i END) AS rank不保留排名,
@score:=a.s_score AS score
FROM (SELECT * FROM score WHERE c_id = '01' GROUP BY s_id, c_id, s_score ORDER BY s_score DESC)a,
(SELECT @i:=0, @k:=0, @score:=0)b)
UNION
(SELECT a.s_id, a.c_id, @m:=@m+1 AS i保留排名,
@k:=(CASE WHEN @score = a.s_score THEN @k ELSE @m END) AS rank不保留排名,
@score:=a.s_score AS score
FROM (SELECT * FROM score WHERE c_id = '02' GROUP BY s_id, c_id, s_score ORDER BY s_score DESC)a,
(SELECT @m:=0, @k:=0, @score:=0)b)
UNION
(SELECT a.s_id, a.c_id, @x:=@x+1 AS i保留排名,
@k:=(CASE WHEN @score = a.s_score THEN @k ELSE @x END) AS rank不保留排名,
@score:=a.s_score AS score
FROM (SELECT * FROM score WHERE c_id = '03' GROUP BY s_id, c_id, s_score ORDER BY s_score DESC)a,
(SELECT @x:=0, @k:=0, @score:=0)b);

# 查询学生的总成绩并进行排名

SELECT score.s_id, s_name, sum(s_score) sumscore
FROM score,
     student
WHERE score.s_id = student.s_id
GROUP BY score.s_id
ORDER BY sumscore DESC;

# 查询不同老师所教不同课程平均分从高到低显示
–方法1

SELECT tmp.c_id, t_id, avgscore AS '平均分'
FROM ((SELECT DISTINCT c_id, (round((SELECT avg(s_score) FROM score WHERE c_id = '01' GROUP BY c_id), 2))avgscore
       FROM score s1
       WHERE c_id = '01')
      UNION
      (SELECT DISTINCT c_id, (round((SELECT avg(s_score) FROM score WHERE c_id = '02' GROUP BY c_id), 2))avgscore
       FROM score s1
       WHERE c_id = '02')
      UNION
      (SELECT DISTINCT c_id, (round((SELECT avg(s_score) FROM score WHERE c_id = '03' GROUP BY c_id), 2))avgscore
       FROM score s1
       WHERE c_id = '03'))tmp,
     course
WHERE tmp.c_id = course.c_id
ORDER BY tmp.avgscore DESC;

–方法2

SELECT course.c_id, course.t_id, t_name, round(avg(s_score), 2)AS avgscore
FROM course
       JOIN teacher ON teacher.t_id = course.t_id
       JOIN score ON course.c_id = score.c_id
GROUP BY score.c_id
ORDER BY avgscore DESC;

–方法3

SELECT course.c_id, course.t_id, t_name, round(avg(s_score), 2)AS avgscore
FROM course,
     teacher,
     score
WHERE teacher.t_id = course.t_id
  AND course.c_id = score.c_id
GROUP BY score.c_id
ORDER BY avgscore DESC;

# 查询所有课程的成绩第2名到第3名的学生信息及该课程成绩
–方法1

(SELECT student.*, tmp1.c_id, tmp1.s_score FROM student,
(SELECT s_id, c_id, s_score FROM score WHERE c_id = '01' ORDER BY s_score DESC LIMIT 1, 2)tmp1
WHERE student.s_id = tmp1.s_id)
UNION (SELECT student.*, tmp2.c_id, tmp2.s_score FROM student,
(SELECT s_id, c_id, s_score FROM score WHERE c_id = '02' ORDER BY s_score DESC LIMIT 1, 2)tmp2
WHERE student.s_id = tmp2.s_id)
UNION (SELECT student.*, tmp3.c_id, tmp3.s_score FROM student,
(SELECT s_id, c_id, s_score FROM score WHERE c_id = '03' ORDER BY s_score DESC LIMIT 1, 2)tmp3
WHERE student.s_id = tmp3.s_id);

–方法2

(SELECT student.*, tmp.c_id, tmp.s_score, tmp.排名 FROM (
SELECT a.s_id, a.c_id, a.s_score, @i:=@i+1 AS 排名 FROM score a, (SELECT @i:=0)b
WHERE a.c_id = '01' ORDER BY a.s_score DESC
)tmp JOIN student ON tmp.s_id = student.s_id WHERE 排名 BETWEEN 2 AND 3)
UNION (
SELECT student.*, tmp.c_id, tmp.s_score, tmp.排名 FROM (
SELECT a.s_id, a.c_id, a.s_score, @j:=@j+1 AS 排名 FROM score a, (SELECT @j:=0)b
WHERE a.c_id = '02' ORDER BY a.s_score DESC
)tmp JOIN student ON tmp.s_id = student.s_id WHERE 排名 BETWEEN 2 AND 3
) UNION (
SELECT student.*, tmp.c_id, tmp.s_score, tmp.排名 FROM (
SELECT a.s_id, a.c_id, a.s_score, @k:=@k+1 AS 排名 FROM score a, (SELECT @k:=0)b
WHERE a.c_id = '03' ORDER BY a.s_score DESC
)tmp JOIN student ON tmp.s_id = student.s_id WHERE 排名 BETWEEN 2 AND 3);

# 统计各科成绩各分数段人数：课程编号,课程名称,[100-85],[85-70],[70-60],[0-60]及所占百分比

SELECT c.c_id,
       c.c_name,
       tmp1.`[0-60]`,
       tmp1.`百分比`,
       tmp2.`[60-70]`,
       tmp2.`百分比`,
       tmp3.`[70-85]`,
       tmp3.`百分比`,
       tmp4.`[85-100]`,
       tmp4.`百分比`
FROM course c
       JOIN (SELECT c_id,
                    sum(CASE WHEN s_score < 60 THEN 1 ELSE 0 END)AS '[0-60]',
                    round(
                      100 * sum(CASE WHEN s_score < 60 THEN 1 ELSE 0 END) / sum(CASE WHEN s_score THEN 1 ELSE 0 END),
                      2)AS                                          百分比
             FROM score
             GROUP BY c_id)tmp1 ON tmp1.c_id = c.c_id
       JOIN (SELECT c_id,
                    sum(CASE WHEN s_score < 70 AND s_score >= 60 THEN 1 ELSE 0 END)AS '[60-70]',
                    round(100 * sum(CASE WHEN s_score < 70 AND s_score >= 60 THEN 1 ELSE 0 END) /
                          sum(CASE WHEN s_score THEN 1 ELSE 0 END), 2)AS              百分比
             FROM score
             GROUP BY c_id)tmp2 ON tmp2.c_id = c.c_id
       JOIN (SELECT c_id,
                    sum(CASE WHEN s_score < 85 AND s_score >= 70 THEN 1 ELSE 0 END)AS '[70-85]',
                    round(100 * sum(CASE WHEN s_score < 85 AND s_score >= 70 THEN 1 ELSE 0 END) /
                          sum(CASE WHEN s_score THEN 1 ELSE 0 END), 2)AS              百分比
             FROM score
             GROUP BY c_id)tmp3 ON tmp3.c_id = c.c_id
       JOIN (SELECT c_id,
                    sum(CASE WHEN s_score >= 85 THEN 1 ELSE 0 END)AS '[85-100]',
                    round(
                      100 * sum(CASE WHEN s_score >= 85 THEN 1 ELSE 0 END) / sum(CASE WHEN s_score THEN 1 ELSE 0 END),
                      2)AS                                           百分比
             FROM score
             GROUP BY c_id)tmp4 ON tmp4.c_id = c.c_id
# 查询学生平均成绩及其名次

SELECT a.s_id, a.s_name, a.平均分, @i := @i + 1 AS 排名
FROM (SELECT student.s_id, student.s_name, avg(score.s_score) AS "平均分"
      FROM student,
           score
      WHERE student.s_id = score.s_id
      GROUP BY score.s_id
      ORDER BY `平均分` DESC)a,
     (SELECT @i := 0)b;

# 查询各科成绩前三名的记录
– 1.选出b表比a表成绩大的所有组
– 2.选出比当前id成绩大的 小于三个的
–没有查学生姓名

(SELECT score.c_id, course.c_name, s_score FROM score, course
WHERE score.c_id = '01' AND course.c_id = score.c_id ORDER BY s_score DESC LIMIT 3)
UNION
(SELECT score.c_id, course.c_name, s_score FROM score, course
WHERE score.c_id = '02' AND course.c_id = score.c_id ORDER BY s_score DESC LIMIT 3)
UNION
(SELECT score.c_id, course.c_name, s_score FROM score, course
WHERE score.c_id = '03' AND course.c_id = score.c_id ORDER BY s_score DESC LIMIT 3);

–查了学生姓名

(SELECT score.c_id, course.c_name, student.s_name, s_score FROM score
JOIN student ON student.s_id = score.s_id
JOIN course ON score.c_id = '01' AND course.c_id = score.c_id ORDER BY s_score DESC LIMIT 3)
UNION (
SELECT score.c_id, course.c_name, student.s_name, s_score FROM score
JOIN student ON student.s_id = score.s_id
JOIN course ON score.c_id = '02' AND course.c_id = score.c_id ORDER BY s_score DESC LIMIT 3

) UNION (
SELECT score.c_id, course.c_name, student.s_name, s_score FROM score
JOIN student ON student.s_id = score.s_id
JOIN course ON score.c_id = '03' AND course.c_id = score.c_id ORDER BY s_score DESC LIMIT 3);

# 查询每门课程被选修的学生数

SELECT c.c_id, c.c_name, a.`被选修人数`
FROM course c
       JOIN (SELECT c_id, count(1) AS `被选修人数` FROM score WHERE score.s_score < 60 GROUP BY score.c_id)a
         ON a.c_id = c.c_id;

# 查询出只有两门课程的全部学生的学号和姓名

SELECT st.s_id, st.s_name
FROM student st
       JOIN (SELECT s_id FROM score GROUP BY s_id HAVING count(c_id) = 2)a ON st.s_id = a.s_id;

# 查询男生、女生人数

SELECT a.男生人数, b.女生人数
FROM (SELECT count(1) AS 男生人数 FROM student WHERE s_sex = '男')a,
     (SELECT count(1) AS 女生人数 FROM student WHERE s_sex = '女')b;

# 查询名字中含有"风"字的学生信息

SELECT *
FROM student
WHERE s_name LIKE '%风%';

# 查询同名同性学生名单，并统计同名人数

SELECT s1.s_id, s1.s_name, s1.s_sex, count(*) AS 同名人数
FROM student s1,
     student s2
WHERE s1.s_name = s2.s_name
  AND s1.s_id <> s2.s_id
  AND s1.s_sex = s2.s_sex
GROUP BY s1.s_name, s1.s_sex;

# 查询1990年出生的学生名单

SELECT *
FROM student
WHERE s_birth LIKE '1990%';
# 查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列

SELECT score.c_id, c_name, round(avg(s_score), 2) AS 平均成绩
FROM score
       JOIN course ON score.c_id = course.c_id
GROUP BY c_id
ORDER BY `平均成绩` DESC, score.c_id ASC;

# 查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩

SELECT score.s_id, s_name, round(avg(s_score), 2)AS 平均成绩
FROM score
       JOIN student ON student.s_id = score.s_id
GROUP BY score.s_id
HAVING `平均成绩` >= 85;

# 查询课程名称为"数学"，且分数低于60的学生姓名和分数

SELECT s_name, s_score AS 数学成绩
FROM student
       JOIN (SELECT s_id, s_score
             FROM score,
                  course
             WHERE score.c_id = course.c_id
               AND c_name = '数学')a ON a.s_score < 60 AND student.s_id = a.s_id;

# 查询所有学生的课程及分数情况

SELECT a.s_name,
       SUM(CASE c.c_name WHEN '语文' THEN b.s_score ELSE 0 END) AS 语文,
       SUM(CASE c.c_name WHEN '数学' THEN b.s_score ELSE 0 END) AS 数学,
       SUM(CASE c.c_name WHEN '英语' THEN b.s_score ELSE 0 END) AS 英语,
       SUM(b.s_score)                                         AS 总分
FROM student a
       JOIN score b ON a.s_id = b.s_id
       JOIN course c ON b.c_id = c.c_id
GROUP BY s_name, a.s_id;

# 查询任何一门课程成绩在70分以上的学生姓名、课程名称和分数

SELECT s_name, c_name, s_score
FROM score
       JOIN student ON student.s_id = score.s_id
       JOIN course ON score.c_id = course.c_id
WHERE s_score < 70;

# 查询不及格的课程

SELECT s_name, c_name AS 不及格课程, tmp.s_score
FROM student
       JOIN (SELECT s_id, s_score, c_name
             FROM score,
                  course
             WHERE score.c_id = course.c_id
               AND s_score < 60)tmp ON student.s_id = tmp.s_id;

# 查询课程编号为01且课程成绩在80分以上的学生的学号和姓名

SELECT student.s_id, s_name, s_score AS score_01
FROM student
       JOIN score ON student.s_id = score.s_id
WHERE c_id = '01'
  AND s_score >= 80;

# 求每门课程的学生人数

SELECT course.c_id, course.c_name, count(1)AS 选课人数
FROM course
       JOIN score ON course.c_id = score.c_id
GROUP BY score.c_id;

# 查询选修"张三"老师所授课程的学生中，成绩最高的学生信息及其成绩
– 查询老师id

SELECT t_id, t_name
FROM teacher
WHERE t_name = '张三';

– 查询最高分（可能有相同分数）

SELECT s_id, c_name, max(s_score)
FROM score
       JOIN (SELECT course.c_id, c_name
             FROM course,
                  (SELECT t_id, t_name FROM teacher WHERE t_name = '张三')tmp
             WHERE course.t_id = tmp.t_id)tmp2 ON score.c_id = tmp2.c_id;

– 查询信息

SELECT student.*, tmp3.c_name AS 课程名称, tmp3.最高分
FROM student
       JOIN (SELECT s_id, c_name, max(s_score)AS 最高分
             FROM score
                    JOIN (SELECT course.c_id, c_name
                          FROM course,
                               (SELECT t_id, t_name FROM teacher WHERE t_name = '张三')tmp
                          WHERE course.t_id = tmp.t_id)tmp2 ON score.c_id = tmp2.c_id)tmp3 ON student.s_id = tmp3.s_id;

# 查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩

SELECT DISTINCT a.s_id, a.c_id, a.s_score
FROM score a,
     score b
WHERE a.c_id <> b.c_id
  AND a.s_score = b.s_score;

# 查询每门课程成绩最好的前两名
–方法1(该方法有bug, 不能查出临界的重复值, 例如查各科的第一名或前三名)

SELECT a.s_id, a.c_id, a.s_score
FROM score a
WHERE (SELECT count(1)
       FROM score b
       WHERE a.c_id = b.c_id
         AND b.s_score >= a.s_score) < 2
ORDER BY a.c_id ASC, a.s_score DESC;

–方法2(查前三名)

(SELECT * FROM score WHERE c_id = '01' ORDER BY s_score DESC LIMIT 3)
UNION (
SELECT * FROM score WHERE c_id = '02' ORDER BY s_score DESC LIMIT 3)
UNION (
SELECT * FROM score WHERE c_id = '03' ORDER BY s_score DESC LIMIT 3);
# 统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列

SELECT DISTINCT course.c_id, tmp.选修人数
FROM course
       JOIN (SELECT c_id, count(1) AS 选修人数 FROM score GROUP BY c_id)tmp
WHERE tmp.选修人数 >= 5
ORDER BY tmp.选修人数 DESC, course.c_id ASC;
# 检索至少选修两门课程的学生学号

SELECT s_id, count(c_id) AS totalCourse
FROM score
GROUP BY s_id
HAVING count(c_id) >= 2;
# 查询选修了全部课程的学生信息

SELECT student.*
FROM student,
     (SELECT s_id, count(c_id) AS totalCourse FROM score GROUP BY s_id)tmp
WHERE student.s_id = tmp.s_id
  AND totalCourse = 3;
# 查询各学生的年龄
– 按照出生日期来算，当前月日 < 出生年月的月日则，年龄减一

SELECT s_name, s_birth, (DATE_FORMAT(NOW(), '%Y') - DATE_FORMAT(s_birth, '%Y') -
                         CASE
                           WHEN (DATE_FORMAT(NOW(), '%m%d') > DATE_FORMAT(s_birth, '%m%d')) THEN 1
                           ELSE 0 END) AS age
FROM student;
# 查询本周过生日的学生
–方法1

SELECT *
FROM student
WHERE WEEK(DATE_FORMAT(NOW(), '%Y%m%d')) + 1 = WEEK(s_birth);
–方法2

SELECT s_name, s_sex, s_birth
FROM student
WHERE substring(s_birth, 6, 2) = '10'
  AND substring(s_birth, 9, 2) = 14;
# 查询下周过生日的学生
–方法1

SELECT *
FROM student
WHERE WEEK(DATE_FORMAT(NOW(), '%Y%m%d')) + 1 = WEEK(s_birth);
–方法2

SELECT s_name, s_sex, s_birth
FROM student
WHERE substring(s_birth, 6, 2) = '10'
  AND substring(s_birth, 9, 2) >= 15
  AND substring(s_birth, 9, 2) <= 21;

# 查询本月过生日的学生
–方法1

SELECT *
FROM student
WHERE MONTH(DATE_FORMAT(NOW(), '%Y%m%d')) + 1 = MONTH(s_birth);
–方法2

SELECT s_name, s_sex, s_birth
FROM student
WHERE substring(s_birth, 6, 2) = '10';