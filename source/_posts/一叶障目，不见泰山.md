---
title: 一叶障目，不见泰山
tags: [SQL,Java]
date: 2019-02-27 00:01:48
updated: 2019-03-04 09:46:27
categories: SQL
---

- 过于草率地相信直觉的判断了，作为一个猜想是需要验证的，想当然才是根源
- 执行力不够，脑袋里产生想法之后一定要立即马上去验证，时间长了就忘了！！（最次也得上备忘录）
- 对于连表的理解有欠缺
- sql语句多学多看，多查，终身学习，不要被其他的边边角角占据了头脑，保持敏锐！


# Update Join / Delete Join
```sql
update table_name_1
inner join table_name_2 on table_name_1.id = table_name_2.uid
inner join table_name_3 on table_name_3.id = table_name_1.tid
set *** = ***
where ***
```
- 说多了都是泪啊

# 获取表中某字段包含某字符串的数据
```sql
SELECT * FROM `表名` WHERE LOCATE('关键字', 字段名)
```
- locate函数的用法

# 连续范围的问题
```sql
# 创建测试表
CREATE TABLE `test_number` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `number` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '数字',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;


# 创建测试数据
insert into test_number values(1,1);
insert into test_number values(2,2);
insert into test_number values(3,3);
insert into test_number values(4,5);
insert into test_number values(5,7);
insert into test_number values(6,8);
insert into test_number values(7,10);
insert into test_number values(8,11);

SELECT min(number) start_range, max(number) end_range
FROM (SELECT number, rn, number - rn diff
      FROM (SELECT number, @number := @number + 1 rn
            FROM test_number,
                 (SELECT @number := 0) AS number) b) c
GROUP BY diff;
```

# 签到问题
```sql
# 创建参考表(模拟数据需要用到)
CREATE TABLE `test_nums` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='参考表';
# 模拟数据，插入 1-1000 连续数据.
create PROCEDURE test()
  BEGIN
    DECLARE i int DEFAULT 1;
    WHILE (i < 1000) DO INSERT INTO test_nums VALUES (i);
      SET i = i + 1;
    END WHILE;
  END;
CALL test();
DROP PROCEDURE test;

# 创建测试表
CREATE TABLE `test_sign_history` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `uid` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '用户ID',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '签到时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='签到历史表';

# 创建测试数据
insert into test_sign_history(uid,create_time)
select ceil(rand()*10000),str_to_date('2016-12-11','%Y-%m-%d')+interval ceil(rand()*10000) minute
from test_nums where id<500;

# 统计每天的每小时用户签到情况
SELECT
       tmp.h,
       sum(CASE WHEN tmp.d = '20161211' THEN tmp.c ELSE 0 END ) as 11sign,
       sum(CASE WHEN tmp.d = '20161212' THEN tmp.c ELSE 0 END ) as 12sign,
       sum(CASE WHEN tmp.d = '20161213' THEN tmp.c ELSE 0 END ) as 13sign,
       sum(CASE WHEN tmp.d = '20161214' THEN tmp.c ELSE 0 END ) as 14sign,
       sum(CASE WHEN tmp.d = '20161215' THEN tmp.c ELSE 0 END ) as 15sign,
       sum(CASE WHEN tmp.d = '20161216' THEN tmp.c ELSE 0 END ) as 16sign,
       sum(CASE WHEN tmp.d = '20161217' THEN tmp.c ELSE 0 END ) as 17sign
FROM
(select hour(create_time) h,date_format(create_time,'%Y%m%d') as d,count(*) c
FROM test_sign_history group BY h,d) tmp
GROUP BY tmp.h ORDER BY tmp.h;

# 统计每天的每小时用户签到情况(当某个小时没有数据时，显示0)
# 主要在于使用了辅助表，使用它用来作为left join 的主表
SELECT
       tmp.h,
       sum(CASE WHEN tmp.d = '20161211' THEN tmp.c ELSE 0 END ) as 11sign,
       sum(CASE WHEN tmp.d = '20161212' THEN tmp.c ELSE 0 END ) as 12sign,
       sum(CASE WHEN tmp.d = '20161213' THEN tmp.c ELSE 0 END ) as 13sign,
       sum(CASE WHEN tmp.d = '20161214' THEN tmp.c ELSE 0 END ) as 14sign,
       sum(CASE WHEN tmp.d = '20161215' THEN tmp.c ELSE 0 END ) as 15sign,
       sum(CASE WHEN tmp.d = '20161216' THEN tmp.c ELSE 0 END ) as 16sign,
       sum(CASE WHEN tmp.d = '20161217' THEN tmp.c ELSE 0 END ) as 17sign
FROM
     (SELECT b.h,tsh.d,tsh.c
     FROM (SELECT id as h FROM test_nums WHERE id <= 24) b
     LEFT JOIN
     (select hour(create_time) h,date_format(create_time,'%Y%m%d') as d,count(*) c
      FROM test_sign_history group BY h,d) tsh ON b.h = tsh.h
     ) tmp
GROUP BY tmp.h ORDER BY tmp.h;

# 统计每天的用户签到数据和每天的增量数据
# 自己想的写法
SELECT t.d, t.cnt, t.cnt - @rown AS increase, @rown := t.cnt
FROM (SELECT date_format(create_time, '%Y%m%d') AS d, count(*) AS cnt
            FROM test_sign_history
      GROUP BY d
      ORDER BY d) t,
     (SELECT @rown := 0) r;


# 参考写法
# 两种写法，思想不同而已
SELECT type,
       sum(CASE WHEN create_time = '2016-12-11' THEN c ELSE 0 END) 11Sign,
       sum(CASE WHEN create_time = '2016-12-12' THEN c ELSE 0 END) 12Sign,
       sum(CASE WHEN create_time = '2016-12-13' THEN c ELSE 0 END) 13Sign,
       sum(CASE WHEN create_time = '2016-12-14' THEN c ELSE 0 END) 14Sign,
       sum(CASE WHEN create_time = '2016-12-15' THEN c ELSE 0 END) 15Sign,
       sum(CASE WHEN create_time = '2016-12-16' THEN c ELSE 0 END) 16Sign,
       sum(CASE WHEN create_time = '2016-12-17' THEN c ELSE 0 END) 17Sign
FROM (SELECT b.create_time, ifnull(b.c - c.c, 0) c, 'Increment' type
      FROM (SELECT date_format(create_time, '%Y-%m-%d') create_time, count(*) c
            FROM test_sign_history
            GROUP BY date_format(create_time, '%Y-%m-%d')) b
             LEFT JOIN (SELECT date_format(create_time, '%Y-%m-%d') create_time, count(*) c
                        FROM test_sign_history
                        GROUP BY date_format(create_time, '%Y-%m-%d')) c
               ON (b.create_time = c.create_time + INTERVAL 1 DAY)
      UNION ALL
      SELECT date_format(create_time, '%Y-%m-%d') create_time, count(*) c, 'Current'
      FROM test_sign_history
      GROUP BY date_format(create_time, '%Y-%m-%d')) a
GROUP BY type
ORDER BY CASE WHEN type = 'Current' THEN 1 ELSE 0 END DESC;


#模拟不同的用户签到了不同的天数
insert into test_sign_history(uid,create_time)
select uid,create_time + interval ceil(rand()*10) day from test_sign_history,test_nums
where test_nums.id <10 order by rand() limit 150;

# 统计签到天数相同的用户数量
SELECT date_format(create_time,'%Y%m%d') as d,count(DISTINCT uid) AS user_cnt
FROM test_sign_history GROUP BY d ORDER BY d;

# 统计每个用户的连续签到时间
# 属于连续问题的解决办法
SELECT tmp2.uid,max(tmp2.sign_last) FROM
       (
       SELECT tmp.uid, min(d) AS begin_date, max(d) AS end_date, datediff(max(d), min(d)) + 1 AS sign_last
        FROM (SELECT ud.uid, ud.d, datediff(ud.d, @time) AS diff, @time := @time + INTERVAL 1 DAY
              FROM (SELECT uid, date_format(create_time, '%Y-%m-%d') AS d
                    FROM test_sign_history
                    GROUP BY uid, d
                    ORDER BY uid, d) ud,
                   (SELECT @time := '2016-01-01') t) tmp
        GROUP BY tmp.uid, tmp.diff
       ) tmp2 GROUP BY tmp2.uid;

# 参考写法
SELECT *
FROM (SELECT d.*, @ggid := @cggid, @cggid := d.uid, if(@ggid = @cggid, @grank := @grank + 1, @grank := 1) grank
      FROM (SELECT uid, min(c.create_time) begin_date, max(c.create_time) end_date, count(*) count
            FROM (SELECT b.*,
                         @gid := @cgid,
                         @cgid := b.uid,
                         if(@gid = @cgid, @rank := @rank + 1, @rank := 1),
                         b.diff - @rank as flag
                  FROM (SELECT DISTINCT uid,
                                        date_format(create_time, '%Y-%m-%d') create_time,
                                        datediff(create_time, now())         diff
                        FROM test_sign_history
                        ORDER BY uid, create_time) b,
                       (SELECT @gid := 1, @cgid := 1, @rank := 1) AS a) c
            GROUP BY uid, flag
            ORDER BY uid, count(*) DESC) d,
           (SELECT @ggid := 1, @cggid := 1, @grank := 1) AS e)f
WHERE grank = 1;

```

[MySQL语句](https://blog.csdn.net/xuebing1995/article/details/74614896#tt_daymode=1)

