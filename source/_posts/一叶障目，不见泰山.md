---
title: 一叶障目，不见泰山
tags: [SQL,Java]
date: 2019-02-27 00:01:48
updated: 2019-03-01 23:37:24
categories: SQL
---

- 过于草率地相信直觉的判断了，作为一个猜想是需要验证的，想当然才是根源
- 执行力不够，脑袋里产生想法之后一定要立即马上去验证，时间长了就忘了！！（最次也得上备忘录）
- 对于连表的理解有欠缺
- sql语句多学多看，多查，终身学习，不要被其他的边边角角占据了头脑，保持敏锐！


# Update Join / Delete Join
```sql
update table_name_1
inner join table_name_2 on table_name_1.id = table_name_2.uid
inner join table_name_3 on table_name_3.id = table_name_1.tid
set *** = ***
where ***
```
- 说多了都是泪啊

# 获取表中某字段包含某字符串的数据
```sql
SELECT * FROM `表名` WHERE LOCATE('关键字', 字段名)
```
- locate函数的用法

# 连续范围的问题
```sql
# 创建测试表
CREATE TABLE `test_number` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `number` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '数字',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;


# 创建测试数据
insert into test_number values(1,1);
insert into test_number values(2,2);
insert into test_number values(3,3);
insert into test_number values(4,5);
insert into test_number values(5,7);
insert into test_number values(6,8);
insert into test_number values(7,10);
insert into test_number values(8,11);

SELECT min(number) start_range, max(number) end_range
FROM (SELECT number, rn, number - rn diff
      FROM (SELECT number, @number := @number + 1 rn
            FROM test_number,
                 (SELECT @number := 0) AS number) b) c
GROUP BY diff;
```

# 签到问题
```sql
# 创建参考表(模拟数据需要用到)
CREATE TABLE `test_nums` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='参考表';
# 模拟数据，插入 1-1000 连续数据.
create PROCEDURE test()
  BEGIN
    DECLARE i int DEFAULT 1;
    WHILE (i < 1000) DO INSERT INTO test_nums VALUES (i);
      SET i = i + 1;
    END WHILE;
  END;
CALL test();
DROP PROCEDURE test;

# 创建测试表
CREATE TABLE `test_sign_history` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `uid` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '用户ID',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '签到时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='签到历史表';

# 创建测试数据
insert into test_sign_history(uid,create_time)
select ceil(rand()*10000),str_to_date('2016-12-11','%Y-%m-%d')+interval ceil(rand()*10000) minute
from test_nums where id<500;

# 统计每天的每小时用户签到情况
SELECT
       tmp.h,
       sum(CASE WHEN tmp.d = '20161211' THEN tmp.c ELSE 0 END ) as 11sign,
       sum(CASE WHEN tmp.d = '20161212' THEN tmp.c ELSE 0 END ) as 12sign,
       sum(CASE WHEN tmp.d = '20161213' THEN tmp.c ELSE 0 END ) as 13sign,
       sum(CASE WHEN tmp.d = '20161214' THEN tmp.c ELSE 0 END ) as 14sign,
       sum(CASE WHEN tmp.d = '20161215' THEN tmp.c ELSE 0 END ) as 15sign,
       sum(CASE WHEN tmp.d = '20161216' THEN tmp.c ELSE 0 END ) as 16sign,
       sum(CASE WHEN tmp.d = '20161217' THEN tmp.c ELSE 0 END ) as 17sign
FROM
(select hour(create_time) h,date_format(create_time,'%Y%m%d') as d,count(*) c
FROM test_sign_history group BY h,d) tmp
GROUP BY tmp.h ORDER BY tmp.h;

# 统计每天的每小时用户签到情况(当某个小时没有数据时，显示0)
# 主要在于使用了辅助表，使用它用来作为left join 的主表
SELECT
       tmp.h,
       sum(CASE WHEN tmp.d = '20161211' THEN tmp.c ELSE 0 END ) as 11sign,
       sum(CASE WHEN tmp.d = '20161212' THEN tmp.c ELSE 0 END ) as 12sign,
       sum(CASE WHEN tmp.d = '20161213' THEN tmp.c ELSE 0 END ) as 13sign,
       sum(CASE WHEN tmp.d = '20161214' THEN tmp.c ELSE 0 END ) as 14sign,
       sum(CASE WHEN tmp.d = '20161215' THEN tmp.c ELSE 0 END ) as 15sign,
       sum(CASE WHEN tmp.d = '20161216' THEN tmp.c ELSE 0 END ) as 16sign,
       sum(CASE WHEN tmp.d = '20161217' THEN tmp.c ELSE 0 END ) as 17sign
FROM
     (SELECT b.h,tsh.d,tsh.c
     FROM (SELECT id as h FROM test_nums WHERE id <= 24) b
     LEFT JOIN
     (select hour(create_time) h,date_format(create_time,'%Y%m%d') as d,count(*) c
      FROM test_sign_history group BY h,d) tsh ON b.h = tsh.h
     ) tmp
GROUP BY tmp.h ORDER BY tmp.h;

# 统计每天的用户签到数据和每天的增量数据

#模拟不同的用户签到了不同的天数
insert into test_sign_history(uid,create_time)
select uid,create_time + interval ceil(rand()*10) day from test_sign_history,test_nums
where test_nums.id <10 order by rand() limit 150;

# 统计签到天数相同的用户数量

# 统计每个用户的连续签到时间

```

